<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/posts/6c92115f.html"/>
    <url>/posts/6c92115f.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 22, 2023</p><h2 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a>Spring 基础</h2><h3 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h3><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p><strong>Spring 特性：</strong></p><p>1.IOC 和 DI 的支持：Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现高内聚低耦合的设计理念。</p><p>2.AOP 的支持：Spring 提供了面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p><p>3.声明式事务的支持：支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。</p><p>4.快捷测试的支持：Spring 对 Junit 提供支持，可以通过注解快捷地测试 Spring 程序。</p><p>5.快速集成功能：方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p><p>6.复杂 API 模板封装：Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。</p><h3 id="Spring-框架有哪些模块"><a href="#Spring-框架有哪些模块" class="headerlink" title="Spring 框架有哪些模块?"></a>Spring 框架有哪些模块?</h3><p>1.<strong>Spring Core：</strong>Spring Core是Spring框架的核心模块，提供了IoC（Inversion of Control）容器的实现和支持。它负责创建、配置和管理应用程序中的对象，并通过依赖注入的方式解耦组件之间的依赖关系。</p><p>2.<strong>Spring AOP：</strong>Spring AOP模块实现了面向切面编程（AOP）的支持。它允许开发者通过定义切点和切面，将横切关注点（如日志记录、性能监控等）与业务逻辑分离，从而提高代码的模块化和可维护性。</p><p>3.<strong>Spring Web MVC：</strong>Spring Web MVC是Spring框架的Web应用程序开发模块。它提供了一种基于MVC（Model-View-Controller）的架构，用于构建灵活、可扩展的Web应用程序。开发者可以使用注解或配置文件定义控制器、视图和模型，并实现Web请求的处理和响应。</p><p>4.<strong>Spring WebFlux：</strong>Spring WebFlux是Spring框架的响应式Web开发模块。它基于反应式编程模型，提供了一种异步、非阻塞的方式处理Web请求。开发者可以使用注解或函数式编程风格定义处理器函数，并利用响应式流处理请求和响应。</p><p>5.<strong>Spring Web：</strong>Spring Web模块是Spring框架的Web应用程序支持模块，提供了与Servlet API和其他Web相关技术的集成。它包括与Web安全、文件上传、WebSockets等相关的功能和工具，帮助开发者构建全功能的Web应用程序。</p><p>6.<strong>Spring DAO：</strong>Spring DAO模块提供了对数据访问对象（DAO）的支持。它简化了与数据库的交互，提供了一组抽象和实现，用于执行CRUD操作、批处理、存储过程调用等。开发者可以集成各种数据访问技术（如JDBC、Hibernate、JPA等）来实现灵活和可扩展的数据访问层。</p><p>7.<strong>Spring ORM：</strong>Spring ORM模块用于集成和支持各种对象关系映射（ORM）框架，如Hibernate、JPA等。它提供了事务管理、异常转换和对象关系映射等功能，简化了与关系型数据库的交互。</p><p>8.<strong>Spring Context：</strong>Spring Context是Spring框架的核心模块之一，实现了IoC容器的功能。它负责管理和组织应用程序中的各个组件，包括Bean管理、依赖注入、生命周期管理、事件机制等。Spring Context提供了一个上下文环境，使得开发者能够更方便地构建和管理应用程序。</p><h3 id="Spring-框架有哪些常用注解"><a href="#Spring-框架有哪些常用注解" class="headerlink" title="Spring 框架有哪些常用注解?"></a>Spring 框架有哪些常用注解?</h3><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202310221544050.png"></p><p>Web: </p><ul><li>@Controller：组合注解（组合了@Component 注解），应用在 MVC 层（控制层）。</li><li>@RestController：该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</li><li>@RequestMapping：用于映射 Web 请求，包括访问路径和参数。如果是 Restful 风格接口，还可以根据请求类型使用不同的注解：<ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li></ul></li><li>@ResponseBody：支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。</li><li>@RequestBody：允许 request 的参数在 request 体中，而不是在直接连接在地址后面。</li><li>@PathVariable：用于接收路径参数，比如 <code>@RequestMapping(&quot;/users/&#123;id&#125;&quot;)</code>申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。</li></ul><p>容器: </p><ul><li>@Component：表示一个带注释的类是一个“组件”，成为 Spring 管理的 Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component 还是一个元注解。</li><li>@Service：组合注解（组合了@Component 注解），应用在 service 层（业务逻辑层）。</li><li>@Repository：组合注解（组合了@Component 注解），应用在 dao 层（数据访问层）。</li><li>@Autowired：Spring 提供的工具（由 Spring 的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</li><li>@Qualifier：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解</li><li>@Configuration：声明当前类是一个配置类（相当于一个 Spring 配置的 xml 文件）</li><li>@Value：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 <code>#&#123;&#125; 跟 \$&#123;&#125;</code> 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。</li><li>@Bean：注解在方法上，声明当前方法的返回值为一个 Bean。返回的 Bean 对应的类中可以定义 init()方法和 destroy()方法，然后在<code>@Bean(initMethod=&quot;init&quot;,destroyMethod=&quot;destroy&quot;)</code>定义，在构造之后执行 init，在销毁之前执行 destroy。</li><li>@Scope:定义我们采用什么模式去创建 Bean（方法上，得有@Bean） 其设置类型包括：Singleton、Prototype、Request、Session、GlobalSession。</li></ul><p>AOP: </p><p>@Aspect:声明一个切面（类上） 使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。</p><ul><li><code>@After</code> ：在方法执行之后执行（方法上）。</li><li><code>@Before</code>：在方法执行之前执行（方法上）。</li><li><code>@Around</code>：在方法执行之前与之后执行（方法上）。</li><li><code>@PointCut</code>：声明切点 在 java 配置类中使用@EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上）。</li></ul><p>事务: </p><p>@Transactional：在要开启事务的方法上使用@Transactional 注解，即可声明式开启事务。</p><h3 id="Spring-框架中应用了哪些设计模式"><a href="#Spring-框架中应用了哪些设计模式" class="headerlink" title="Spring 框架中应用了哪些设计模式?"></a>Spring 框架中应用了哪些设计模式?</h3><p>1.<strong>工厂模式</strong>: Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</p><p>2.<strong>代理模式</strong>: Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</p><p>3.<strong>单例模式</strong>: Spring 中的 Bean 默认都是单例的，这样有利于容器对 Bean 的管理。</p><p>4.<strong>模板模式</strong>: Spring 中 JdbcTemplate、RestTemplate 等以 Template 结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模5.。</p><p>5.<strong>观察者模式</strong>: Spring 事件驱动模型就是观察者模式很经典的一个应用。</p><p>6.<strong>适配器模式</strong>: Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</p><p>7.<strong>策略模式</strong>: Spring 中有一个 Resource 接口，它的不同实现类，会根据不同的策略去访问资源。</p><h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><h3 id="什么是-IOC-和-DI"><a href="#什么是-IOC-和-DI" class="headerlink" title="什么是 IOC 和 DI?"></a>什么是 IOC 和 DI?</h3><p><strong>IOC（Inversion of Control:控制反转）</strong>是一种设计思想，而不是一个具体的技术实现。IOC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring IOC 容器来管理。</p><p><strong>DI（Dependency Injection:依赖注入）</strong>是指将对象所依赖的其他对象通过构造函数、Setter 方法或其他方式注入到对象中，从而消除了对象之间的耦合关系。</p><blockquote><p>IOC 是一种思想，它强调将对象之间的依赖关系的控制权交给容器来管理；DI 则是一种具体的实现方式，它强调将对象所依赖的其他对象通过注入的方式来消除对象之间的耦合关系。</p></blockquote><blockquote><p><strong>为什么要使用 IOC?</strong></p><p>最核心的是两个字<strong>解耦</strong>，硬编码会造成对象间的过度耦合，使用 IOC 之后，我们可以不用关心对象间的依赖。</p></blockquote><h3 id="有哪些依赖注入的实现方式"><a href="#有哪些依赖注入的实现方式" class="headerlink" title="有哪些依赖注入的实现方式?"></a>有哪些依赖注入的实现方式?</h3><ul><li><strong>构造器注入：</strong>是指通过构造方法将依赖项注入到对象中。在构造方法中，将依赖项作为参数传入，然后在对象被创建时将其保存在成员变量中。</li><li><strong>setter注入：</strong>是指通过setter方法将依赖项注入到对象中。在setter方法中，将依赖项作为参数传入，然后将其保存在成员变量中。</li><li><strong>接口注入：</strong>是指通过实现接口将依赖项注入到对象中。在接口中定义依赖项的setter方法，然后在实现类中实现该方法，将依赖项注入到对象中。</li><li><strong>注解注入：</strong>是指通过注解将依赖项注入到对象中。在依赖项上添加注解，然后在对象中使用@Autowired、@Resource注解将依赖项注入到对象中。</li></ul><h3 id="什么是-Spring-Bean"><a href="#什么是-Spring-Bean" class="headerlink" title="什么是 Spring Bean?"></a>什么是 Spring Bean?</h3><p>Bean 是那些被 Spring IoC 容器管理的对象。简单来说，Bean 就是通过 Spring 容器创建、装配和管理的对象实例。它可以是任何一个普通的 Java 对象，例如 POJO（普通的 Java 对象）、Service、DAO、Entity 等等。</p><h3 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h3><p><strong>singleton</strong>: IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</p><p><strong>prototype</strong>: 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</p><p><strong>request</strong>（仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</p><p><strong>session</strong>（仅 Web 应用可用）: 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</p><p><strong>application&#x2F;global-session</strong>（仅 Web 应用可用）: 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</p><p><strong>websocket</strong>（仅 Web 应用可用）: 每一次 WebSocket 会话产生一个新的 bean。</p><blockquote><p><strong>如何配置 bean 的作用域?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// xml方式</span><br>&lt;bean id=<span class="hljs-string">&quot;...&quot;</span> class=<span class="hljs-string">&quot;...&quot;</span> scope=<span class="hljs-string">&quot;singleton&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注解方式</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">personPrototype</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="了解-Spring-Bean-的生命周期吗"><a href="#了解-Spring-Bean-的生命周期吗" class="headerlink" title="了解 Spring Bean 的生命周期吗?"></a>了解 Spring Bean 的生命周期吗?</h3><p>Spring IOC 中 Bean 的生命周期大致分为五个阶段：<strong>实例化</strong>（Instantiation）、<strong>属性赋值</strong>（Populate）、<strong>初始化</strong>（Initialization 、<strong>使用</strong>、<strong>销毁</strong>（Destruction）。</p><blockquote><p>在 Spring 中，基本容器 BeanFactory 和扩展容器 ApplicationContext 的实例化时机不太一样，BeanFactory 采用的是延迟初始化的方式，也就是只有在第一次 getBean()的时候，才会实例化 Bean；ApplicationContext 启动之后会实例化所有的 Bean 定义。</p></blockquote><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202310231532049.png"></p><ul><li><p><strong>实例化：</strong>实例化一个 Bean 对象，为 Bean 分配内存空间</p></li><li><p><strong>属性赋值：</strong>为 Bean 设置相关属性和依赖</p></li><li><p><strong>初始化：</strong></p><ul><li>执行各种通知</li><li>执行初始化的前置方法</li><li>执行初始化方法</li><li>执行初始化的后置方法</li></ul></li><li><p><strong>使用：</strong>在程序中使用 Bean 对象</p></li><li><p><strong>销毁：</strong>将 Bean 对象进行销毁</p></li></ul><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202310231539982.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO流</title>
    <link href="/posts/59ae8782.html"/>
    <url>/posts/59ae8782.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 19, 2023</p><h2 id="IO-流概述"><a href="#IO-流概述" class="headerlink" title="IO 流概述"></a>IO 流概述</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p><p><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p><p>IO 流体系结构图：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310211439867.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO流</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/posts/3e225941.html"/>
    <url>/posts/3e225941.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 13, 2023</p><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><h3 id="什么是进程和线程"><a href="#什么是进程和线程" class="headerlink" title="什么是进程和线程?"></a>什么是进程和线程?</h3><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位。</p><p><strong>线程</strong>是进程的一个执行路径，一个进程中至少包含一个线程，进程中的多个线程共享进程的堆和方法区资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><blockquote><p><strong>引入线程前，进程是资源分配和独立调度的基本单位。引入线程后，进程是资源分配的基本单位，线程是独立调度的基本单位。</strong></p></blockquote><blockquote><p><strong>程序计数器为什么是私有的?</strong></p><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p></blockquote><blockquote><p><strong>虚拟机栈和本地方法栈为什么是私有的?</strong></p><p>虚拟机栈和本地方法栈私有是为了<strong>保证线程中的局部变量不被别的线程访问到</strong>。</p></blockquote><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别?"></a>进程和线程的区别?</h3><ul><li>进程是资源（包括内存、打开的文件等）分配的基本单位，线程是 CPU 调度的基本单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源；</li><li>线程能减少并发执行的时间和空间开销，但不利于资源的管理和保护，而进程正相反。</li></ul><h3 id="什么是并发与并行"><a href="#什么是并发与并行" class="headerlink" title="什么是并发与并行?"></a>什么是并发与并行?</h3><p><strong>并发：</strong>宏观上在<strong>一段时间</strong>内能同时运行多个程序。当然，这些程序宏观上是同时发生的，但微观上是交替发生的。操作系统通过引入进程和线程，使得程序能够并发运行。</p><p><strong>并行：</strong>并行指<strong>同一时刻</strong>能运行多个指令，指两个或多个事件在同一时刻同时发生。</p><h3 id="什么是同步和异步"><a href="#什么是同步和异步" class="headerlink" title="什么是同步和异步?"></a>什么是同步和异步?</h3><p><strong>同步：</strong>发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</p><p><strong>异步：</strong>调用在发出之后，不用等待返回结果，该调用直接返回。</p><h3 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h3><table><thead><tr><th align="center">状态</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NEW</td><td align="center">初始状态：线程被创建，但还没有调用start()方法</td></tr><tr><td align="center">RUNNABLE</td><td align="center">当调用了 start 方法后，线程就进入了运行状态（RUNNABLE ），Java 线程将操作系统中线程的就绪（READY）和运行（RUNNING）两种状态统称为 “RUNNABLE”。</td></tr><tr><td align="center">BLOCKED</td><td align="center">阻塞状态：表示线程阻塞于锁</td></tr><tr><td align="center">WAITING</td><td align="center">等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td align="center">TIME_WAITING</td><td align="center">超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</td></tr><tr><td align="center">TERMINATED</td><td align="center">终止状态，表示该线程已经运行完毕。</td></tr></tbody></table><p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310132019366.jpg"></p><h3 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换?"></a>什么是线程上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><blockquote><p>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</p><p>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</p><p>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</p><p>被终止或结束运行</p></blockquote><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><h3 id="了解守护线程吗"><a href="#了解守护线程吗" class="headerlink" title="了解守护线程吗?"></a>了解守护线程吗?</h3><p><strong>Java 中的线程分为两类，分别为 daemon 线程(守护线程)和 user 线程(用户线程)。</strong>在 JVM 启动时会调用 main 函数，main函数所在的线程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程，比如 GC 线程(垃圾回收线程)。</p><p>守护线程的使用有以下要点：</p><ul><li>当程序中所有的用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出(也就是说只要存在一个用户线程在运行，守护线程就不会结束)。</li><li>守护线程必须在 <code>start</code> 启动前通过 <code>setDaemon()</code> 方法将状态设置为 true，启动后不能进行设置，否则报 <code>InterruptedException</code> 异常。</li><li>守护线程存在被 JVM 强制终止的风险，所以在守护线程中尽量不去访问系统资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失，<strong>所以守护线程适合执行无需完整执行的后台任务</strong>。</li><li>守护线程中创建的线程也是守护线程。</li></ul><blockquote><p><strong>Java 默认有几个线程?</strong></p><p>两个，<strong>main</strong>线程和<strong>GC</strong>线程。</p></blockquote><h3 id="说说线程的几种创建方式"><a href="#说说线程的几种创建方式" class="headerlink" title="说说线程的几种创建方式?"></a>说说线程的几种创建方式?</h3><p>Java 中创建线程主要有三种方式，分别为继承 <code>Thread</code> 类、实现 <code>Runnable</code> 接口、实现 <code>Callable</code> 接口。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310142230148.jpg"></p><p>1.继承 <code>Thread</code> 类并重写 <code>run()</code> 方法，创建一个线程对象，调用 <code>start()</code> 方法启动线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure><p>2.实现 <code>Runnable</code> 接口并实现 <code>run()</code> 方法，创建一个 <code>Runnable</code> 对象，将该对象作为参数传入 <code>Thread</code> 的构造方法中，创建一个线程对象，调用 <code>start()</code> 方法启动线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br></code></pre></td></tr></table></figure><p>3.实现 <code>Callable</code> 接口并实现 <code>call()</code> 方法，创建一个 <code>Callable</code> 对象，将该对象作为参数传入 <code>FutureTask</code> 的构造方法中，创建一个 <code>FutureTask</code> 对象，将 <code>FutureTask</code> 对象作为参数传入 <code>Thread</code> 的构造方法中，创建一个线程对象，调用 <code>start()</code> 方法启动线程。可以使用 <code>FutureTask</code>对象中的 <code>get()</code> 方法获取 <code>call()</code> 方法的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程要执行的代码</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>thread.start();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br></code></pre></td></tr></table></figure><h3 id="说说-Runnable-接口和-Callable-接口的区别"><a href="#说说-Runnable-接口和-Callable-接口的区别" class="headerlink" title="说说 Runnable 接口和 Callable 接口的区别?"></a>说说 Runnable 接口和 Callable 接口的区别?</h3><p>1.<code>Runnable</code> 接口 <code>run()</code> 方法没有返回值；<code>Callable</code> 接口 <code>call()</code> 方法有返回值，是个泛型，和 <code>Future</code>、 <code>FutureTask</code> 配合可以用来获取异步执行的结果 (需要调用 <code>FutureTask.get()</code> 方法得到， 此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞)。</p><p>2.<code>Runnable</code> 接口 <code>run()</code> 方法只能抛出运行时异常，且无法捕获处理；<code>Callable</code> 接口 <code>call()</code> 方法允许抛出异常，可以获取异常信息。</p><h3 id="调用-start-方法时会执行-run-方法，那为什么不直接调用-run-方法"><a href="#调用-start-方法时会执行-run-方法，那为什么不直接调用-run-方法" class="headerlink" title="调用 start() 方法时会执行 run() 方法，那为什么不直接调用 run() 方法?"></a>调用 start() 方法时会执行 run() 方法，那为什么不直接调用 run() 方法?</h3><p><code>run()</code> 方法被称为<strong>线程执行体</strong>，它的方法体代表了线程需要完成的任务，而 <code>start()</code> 方法是用来启动线程的。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。</p><p>如果直接调用线程对象的 <code>run()</code> 方法，则 <code>run()</code> 方法立即就会被执行，而且在 <code>run()</code> 方法返回之前其他线程无法并发执行。<strong>也就是说，如果直接调用线程对象的 <code>run()</code> 方法，系统把线程对象当成一个普通对象，而 <code>run()</code> 方法也是一个普通方法，而不是线程执行体</strong>。</p><h3 id="知道-sleep-方法和-wait-方法的区别吗"><a href="#知道-sleep-方法和-wait-方法的区别吗" class="headerlink" title="知道 sleep() 方法和 wait() 方法的区别吗?"></a>知道 sleep() 方法和 wait() 方法的区别吗?</h3><ul><li><code>sleep()</code> 方法是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 方法则是 <code>Object</code> 类的本地方法。</li><li><strong><code>sleep()</code> 方法不会释放锁，而 <code>wait()</code> 方法会释放锁</strong> 。</li><li><code>sleep()</code>方法一般用于暂停线程执行，而 <code>wait()</code> 方法用于线程之间的通信。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>wait()</code> 方法只能在 被 <code>synchronized</code> 修饰的方法或者代码块里面使用，而 <code>sleep()</code> 方法可以在任何地方使用。</li></ul><blockquote><p><strong>Thread.sleep(0) 有什么用?</strong></p><p>sleep(timeout) 的意思是，线程丢掉 CPU 时间片，挂起 timeout 秒，进入等待态（等待队列中的线程是不参与 CPU 调度的），timeout 秒之后，再转入就绪态，开始等候 CPU 调度。</p><p><strong>当一个线程调用 <code>Thread.sleep(0)</code> 方法时，它会立即放弃自己的 CPU 时间片，然后直接进入就绪态，继续参与 CPU 调度，使得其他等待线程有机会先执行，如果没有其他等待线程，则当前线程会继续执行。这种方式可以防止当前线程长时间占用 CPU 而导致其他线程无法执行的问题，从而提高系统的并发性能</strong>。</p></blockquote><h2 id="Java-内存模型-JMM"><a href="#Java-内存模型-JMM" class="headerlink" title="Java 内存模型(JMM)"></a>Java 内存模型(JMM)</h2><h3 id="知道原子性、可见性、有序性吗"><a href="#知道原子性、可见性、有序性吗" class="headerlink" title="知道原子性、可见性、有序性吗?"></a>知道原子性、可见性、有序性吗?</h3><ul><li><strong>原子性：</strong>指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行( JMM 只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用 <code>synchronized</code> 关键字)。</li><li><strong>可见性：</strong>指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改( Java 使用 <code>volatile</code> 关键字来保证可见性的，除此之外，使用<code>final</code> 和 <code>synchronized</code> 关键字也能保证可见性)。</li><li><strong>有序性：</strong>指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排(<code>synchronized</code> 或者 <code>volatile</code> 关键字都可以保证多线程之间操作的有序性)。</li></ul><blockquote><p><strong>如何保证变量的可见性?</strong></p><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p></blockquote><h3 id="什么是指令重排"><a href="#什么是指令重排" class="headerlink" title="什么是指令重排?"></a>什么是指令重排?</h3><p>指令的重排序：Java 语言规范规定了JVM线程内部维持顺序化语义，也就是说<strong>只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致</strong>。</p><p>指令重排序的意义在于：JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。</p><blockquote><p>重排序的分类：</p><p>1.编译期重排：编译源代码时，编译器依据对上下文的分析，对指令进行重排序，以之更适合于CPU的并行执行。</p><p>2.运行期重排：CPU在执行过程中，动态分析依赖部件的效能，对指令做重排序优化。</p><p>3.内存重排：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></blockquote><h3 id="如何禁止指令重排序"><a href="#如何禁止指令重排序" class="headerlink" title="如何禁止指令重排序?"></a>如何禁止指令重排序?</h3><p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><p>我们比较熟悉的双重校验锁实现单例模式就是一个经典的指令重排的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 双重校验锁实现对象单例（线程安全）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的，<code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><p>1.为 <code>uniqueInstance</code> 分配内存空间</p><p>2.初始化 <code>uniqueInstance</code></p><p>3.将 <code>uniqueInstance</code> 指向分配的内存地址</p><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized-是什么？有什么用"><a href="#synchronized-是什么？有什么用" class="headerlink" title="synchronized 是什么？有什么用?"></a>synchronized 是什么？有什么用?</h3><p><code>synchronized</code> 是 Java 中的一个关键字，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>在 Java 早期版本中，<code>synchronized</code> 属于<strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>在 Java 6 之后，<code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此，<code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 关键字。</p><h3 id="怎么使用-synchronized-关键字"><a href="#怎么使用-synchronized-关键字" class="headerlink" title="怎么使用 synchronized 关键字?"></a>怎么使用 synchronized 关键字?</h3><p><code>synchronized</code> 关键字的使用方式主要有 3 种: 修饰实例方法、修饰静态方法、修饰代码块。</p><p>1.修饰实例方法（锁当前实例对象）: </p><p>给当前对象实例加锁，进入同步代码前要获得<strong>当前对象实例的锁</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.修饰静态方法（锁当前类）: </p><p>给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得<strong>当前 class 的锁</strong>。这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？</p><p>不互斥，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p></blockquote><p>3.修饰代码块（锁指定对象&#x2F;类）: </p><ul><li><code>synchronized(object)</code> 表示进入同步代码前要获得<strong>给定对象的锁</strong>。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得<strong>给定 Class 的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">// 业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</li></ul></blockquote><blockquote><p>构造方法可以用 synchronized 关键字修饰吗?</p><p>构造方法本身就是属于线程安全的，所以<strong>不能使用 synchronized 关键字修饰</strong>。</p></blockquote><h3 id="JDK-1-6-之后-synchronized-底层做了哪些优化"><a href="#JDK-1-6-之后-synchronized-底层做了哪些优化" class="headerlink" title="JDK 1.6 之后 synchronized 底层做了哪些优化?"></a>JDK 1.6 之后 synchronized 底层做了哪些优化?</h3><p>JDK 1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><ul><li>偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS 操作都不做。</li><li>轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有 CAS 操作的开销。</li><li>自旋锁：减少不必要的 CPU 上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</li><li>锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li>锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</li></ul><blockquote><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p>锁升级方向：无锁—&gt;偏向锁—&gt; 轻量级锁—&gt;重量级锁</p></blockquote><h3 id="说说-synchronized-和-volatile-的区别"><a href="#说说-synchronized-和-volatile-的区别" class="headerlink" title="说说 synchronized 和 volatile 的区别?"></a>说说 synchronized 和 volatile 的区别?</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在。</p><p>1.<code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</p><p>2.<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p><p>3.<code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</p><h3 id="说说-synchronized-和-Lock-的区别"><a href="#说说-synchronized-和-Lock-的区别" class="headerlink" title="说说 synchronized 和 Lock 的区别?"></a>说说 synchronized 和 Lock 的区别?</h3><p>1.<code>synchronized</code> 是 Java 内置关键字；而<code>Lock</code> 是 java.util.concurrent.locks 包下的一个接口。</p><p>2.<code>synchronized</code> 可以给类、方法、代码块加锁；而 <code>Lock</code> 只能给代码块加锁。</p><p>3.<code>synchronized</code> 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 <code>Lock</code> 需要手动加锁和释放锁，如果使用不当没有使用 <code>unlock()</code> 方法去释放锁就会造成死锁。**(所以最好将同步代码块用 <code>try catch</code> 包起来，<code>finally</code> 中写入 <code>unlock()</code>方法，避免死锁的发生)**</p><p>4.<code>Lock</code> 可以通过 <code>tryLock()</code> 方法判断是否获取到了锁，而 <code>synchronized</code> 不能。</p><p>5.<code>synchronized</code> 是可重入锁、不可中断、非公平锁。<code>Lock</code> 是可重入锁、可中断、可公平。</p><h3 id="ReentrantLock-是什么"><a href="#ReentrantLock-是什么" class="headerlink" title="ReentrantLock 是什么?"></a>ReentrantLock 是什么?</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。<code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么是公平锁和非公平锁"><a href="#什么是公平锁和非公平锁" class="headerlink" title="什么是公平锁和非公平锁?"></a>什么是公平锁和非公平锁?</h3><p><strong>公平锁:</strong> 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p><p><strong>非公平锁:</strong> 锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p><h3 id="什么是可中断锁和不可中断锁"><a href="#什么是可中断锁和不可中断锁" class="headerlink" title="什么是可中断锁和不可中断锁?"></a>什么是可中断锁和不可中断锁?</h3><p><strong>可中断锁:</strong> 获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</p><p><strong>不可中断锁:</strong> 一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</p><h3 id="什么是共享锁和独占锁"><a href="#什么是共享锁和独占锁" class="headerlink" title="什么是共享锁和独占锁?"></a>什么是共享锁和独占锁?</h3><p><strong>共享锁:</strong> 一把锁可以被多个线程同时获得。</p><p><strong>独占锁:</strong> 一把锁只能被一个线程获得。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁?"></a>什么是死锁?</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><blockquote><p><strong>产生死锁的四个必要条件：</strong></p><p>1.互斥条件：该资源任意一个时刻只由一个线程占用。</p><p>2.请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>3.不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p>4.环路等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</p></blockquote><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁?"></a>如何避免死锁?</h4><p><strong>至少破坏死锁发生的一个条件：</strong></p><blockquote><p><strong>互斥条件没有办法破坏，因为用锁为的就是互斥。</strong></p><p><strong>破坏请求与保持条件：</strong>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件：</strong>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件：</strong>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></blockquote><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么?"></a>ThreadLocal 是什么?</h3><p><code>ThreadLocal</code>，也就是线程本地变量。如果创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个ThreadLocal变量，任何一个线程都能并发访问localVariable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程可以在任何地方使用localVariable，写入变量</span><br>localVariable.set(<span class="hljs-string">&quot;Java&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程在任何地方读取的都是它写入的变量</span><br>localVariable.get();<br></code></pre></td></tr></table></figure><h3 id="了解-ThreadLocal-内存泄漏吗"><a href="#了解-ThreadLocal-内存泄漏吗" class="headerlink" title="了解 ThreadLocal 内存泄漏吗?"></a>了解 ThreadLocal 内存泄漏吗?</h3><p><code>ThreadLocalMap</code> 中的 key 为 <code>ThreadLocal</code> 的弱引用，value 为强引用，如果 <code>ThreadLocal</code> 没有被外部强引用，垃圾回收时 key 会被清理掉，但value不会；这时 key &#x3D; null，而 value !&#x3D; null，如果不做处理，value 将永远不会被GC掉，就有可能发生内存泄漏。</p><p><code>ThreadLocalMap</code> 的实现中考虑了这个问题，在调用 get()&#x2F;set()&#x2F;remove() 方法时会清理掉 key &#x3D; null 的 entry，在编程时如果意识到当前编写的 run() 方法里不再会使用 <code>ThreadLocal</code> 了，最好手动调用 remove()方法。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池?"></a>什么是线程池?</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><blockquote><p><strong>线程池的优势:</strong></p><p><strong>1.降低资源消耗:</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p><strong>2.提高响应速度:</strong> 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p><strong>3.提高线程的可管理性:</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></blockquote><h3 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h3><p><strong>方式一：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建</strong></p><p>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p><p><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p><p><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</p><p>**<code>ScheduledThreadPool</code>**：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</p><blockquote><p>《阿里巴巴 Java 开发手册》中不允许使用 <code>Executors</code> 创建线程池，这是因为两点，一是Executors提供的模板不够灵活，多数情况需要程序员自定义线程池，二是模板容易造成内存溢出（1和2队列过载、3线程池过载）。</p></blockquote><p><strong>方式二：通过 <code>ThreadPoolExecutor</code> 构造方法创建</strong></p><p><code>ThreadPoolExecutor</code> 一共有4个构造器，其中最核心的就是下面给出的，另外 3 个只是在其基础上为一些参数设定了默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"><strong>参数</strong></th><th align="center"><strong>类型</strong></th><th align="center"><strong>意义</strong></th></tr></thead><tbody><tr><td align="center">corePoolSize</td><td align="center">int</td><td align="center">核心线程池容量</td></tr><tr><td align="center">maximumPoolSize</td><td align="center">int</td><td align="center">线程池总容量</td></tr><tr><td align="center">keepAliveTime</td><td align="center">long</td><td align="center">核心外线程最大空闲时间，空闲超过这个时间就会被销毁</td></tr><tr><td align="center">unit</td><td align="center">TimeUnit</td><td align="center">keepAliveTime 的时间单位</td></tr><tr><td align="center">workQueue</td><td align="center">BlockingQueue</td><td align="center">任务队列</td></tr><tr><td align="center">threadFactory</td><td align="center">ThreadFactory</td><td align="center">产生线程的工厂</td></tr><tr><td align="center">handler</td><td align="center">RejectedExecutionHandler</td><td align="center">拒绝执行处理器，当线程池饱和时，按照该参数对应的饱和策略对新任务进行拒绝处理</td></tr></tbody></table><p><strong>线程池的饱和策略：</strong></p><p><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</p><p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</p><p><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</p><p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>本文仅用于个人学习，不涉及出售或倒卖</p><p>文中部分引用 JavaGuide 作者网站中的内容，<a href="https://javaguide.cn/">了解详情戳此处</a>。</p><p>文中部分引用 三分恶 作者网站中的内容，<a href="https://javabetter.cn/">了解详情戳此处</a>。</p><p>文中部分引用 CSView 作者网站中的内容，<a href="https://www.csview.cn/">了解详情戳此处</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合篇</title>
    <link href="/posts/55d6653c.html"/>
    <url>/posts/55d6653c.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 05, 2023</p><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h3 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><p>Java 集合框架如下图所示：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310051433999.png"></p><h3 id="知道-List-Set-Queue-Map-四者的区别吗"><a href="#知道-List-Set-Queue-Map-四者的区别吗" class="headerlink" title="知道 List, Set, Queue, Map 四者的区别吗?"></a>知道 List, Set, Queue, Map 四者的区别吗?</h3><p><code>List</code>：存储的元素是有序的、可重复的。</p><p><code>Set</code>：存储的元素不可重复的。</p><p><code>Queue</code>：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><p><code>Map</code>：使用键值对（key-value）存储；key 是无序的、不可重复的；value 是无序的、可重复的，每个键最多映射到一个值。</p><h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p><code>ArrayList</code>：<code>Object[]</code> 数组</p><p><code>Vector</code>：<code>Object[]</code> 数组</p><p><code>LinkedList</code>：双向链表(JDK 1.6 之前为循环链表，JDK 1.7 取消了循环)</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</p><p><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</p><p><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</p><p><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>HashMap</code>：</p><p>JDK 1.8 之前由数组+链表组成，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（”拉链法”解决冲突）。</p><blockquote><p>拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></blockquote><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310052110150.png"></p><p>JDK 1.8 以后由数组+链表&#x2F;红黑树组成，在解决哈希冲突时有了较大的变化，当链表长度大于 8 并且数组长度大于等于 64（如果当前数组的长度小于 64，那么会选择先进行数组扩容）时将链表转化为红黑树，以减少搜索时间。如果红黑树节点个数小于 6 ，退化为链表。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310052111698.png"></p><p><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑</p><p><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</p><p><code>TreeMap</code>：红黑树（自平衡的排序二叉树）</p><h2 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h2><h3 id="说说ArrayList-和-Array（数组）的区别"><a href="#说说ArrayList-和-Array（数组）的区别" class="headerlink" title="说说ArrayList 和 Array（数组）的区别?"></a>说说ArrayList 和 Array（数组）的区别?</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活。</p><p><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</p><p><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</p><p><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</p><p><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</p><p><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</p><h3 id="知道ArrayList-插入和删除元素的时间复杂度吗"><a href="#知道ArrayList-插入和删除元素的时间复杂度吗" class="headerlink" title="知道ArrayList 插入和删除元素的时间复杂度吗?"></a>知道ArrayList 插入和删除元素的时间复杂度吗?</h3><p><strong>插入</strong>：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 <code>O(n)</code>。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 <code>O(1)</code>，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 <code>O(n)</code> 的操作将原数组复制到新的更大的数组中，然后再执行 <code>O(1)</code> 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 <code>O(n)</code>。</li></ul><p><strong>删除</strong>：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 <code>O(n)</code>。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 <code>O(1)</code>。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 <code>O(n)</code>。</li></ul><blockquote><p><strong>LinkedList 插入和删除元素的时间复杂度?</strong></p><p>1.头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 <code>O(1)</code>。</p><p>2.尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 <code>O(1)</code>。</p><p>3.指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 <code>O(n)</code>。</p></blockquote><h3 id="知道-ArrayList-的扩容机制吗"><a href="#知道-ArrayList-的扩容机制吗" class="headerlink" title="知道 ArrayList 的扩容机制吗?"></a>知道 ArrayList 的扩容机制吗?</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，所以最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 1.8</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断数组是否越界</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-comment">// 扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 1.5倍</span><br>    <br>    <span class="hljs-comment">// 检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行)hugeCapacity()方法来比较 minCapacity 和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-comment">// 如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为Integer.MAX_VALUE - 8</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h2><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p><strong>相同点：</strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都是线程不安全的。</p><p><strong>不同点：</strong></p><p>（1）底层数据结构不同：<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p><p>（2）应用场景不同：<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p><h2 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h3><blockquote><p>initCapacity：初始容量（默认16）</p><p>loadFactor：负载因子（默认0.75）</p><p>threshold：阈值（initCapacity * loadFactor）</p></blockquote><p>JDK 1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><blockquote><p><strong>扰动函数：</strong>指的是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法，换句话说使用扰动函数之后可以减少碰撞。</p></blockquote><p>JDK 1.8 以后由数组+链表&#x2F;红黑树组成，在解决哈希冲突时有了较大的变化，当链表长度大于 8 并且数组长度大于等于 64（如果当前数组的长度小于 64，那么会选择先进行数组扩容）时，将链表转化为红黑树，以减少搜索时间。如果红黑树节点个数小于 6 ，退化为链表。</p><blockquote><p>TreeMap、TreeSet 以及 JDK 1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><h3 id="说说-HashMap-和-Hashtable-的区别"><a href="#说说-HashMap-和-Hashtable-的区别" class="headerlink" title="说说 HashMap 和 Hashtable 的区别?"></a>说说 HashMap 和 Hashtable 的区别?</h3><p><strong>1.底层数据结构：</strong> JDK 1.8 之前由数组+链表组成，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的；JDK 1.8 以后由数组+链表&#x2F;红黑树组成，在解决哈希冲突时有了较大的变化，当链表长度大于 8 并且数组长度大于等于 64（如果当前数组的长度小于 64，那么会选择先进行数组扩容）时，将链表转化为红黑树，以减少搜索时间。如果红黑树节点个数小于 6 ，退化为链表。而<code>Hashtable</code> 没有这样的机制。</p><p><strong>2.对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p><p><strong>3.初始容量大小和每次扩充容量大小的不同：</strong>（1）创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n + 1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。（2）创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p><p><strong>4.线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果要保证线程安全的话就使用 <code>ConcurrentHashMap</code> ）。</p><p><strong>5.效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它。</p><h3 id="了解-HashMap-的-put-方法吗"><a href="#了解-HashMap-的-put-方法吗" class="headerlink" title="了解 HashMap 的 put 方法吗?"></a>了解 HashMap 的 put 方法吗?</h3><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310092106561.png"></p><p>①.判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；</p><p>②.根据键值 key 计算 hash 值得到插入的数组索引i，如果 table[i]&#x3D;&#x3D;null，直接新建节点添加，转向 ⑥，如果table[i] 不为空，转向 ③；</p><p>③.判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向 ④，这里的相同指的是 hashCode 以及 equals；</p><p>④.判断table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向 ⑤；</p><p>⑤.遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。</p><p>JDK 1.8 HashMap 的 put 方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// 对key的hashCode()做hash</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// 步骤①：tab为空则创建</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 步骤②：计算index，并对null做处理 </span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>) <br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 步骤③：节点key存在，直接覆盖value</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 步骤④：判断该链为红黑树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 步骤⑤：该链为链表</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key,value,<span class="hljs-literal">null</span>);<br>                     <span class="hljs-comment">//链表长度大于8转换为红黑树进行处理</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st  </span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                 <span class="hljs-comment">// key已经存在直接覆盖value</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) <br>                           <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 步骤⑥：超过最大容量 就扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK-1-8-对-HashMap-做了哪些优化"><a href="#JDK-1-8-对-HashMap-做了哪些优化" class="headerlink" title="JDK 1.8 对 HashMap 做了哪些优化?"></a>JDK 1.8 对 HashMap 做了哪些优化?</h3><p><strong>1.数据结构：</strong>JDK 1.7 采用数组 + 链表，JDK 1.8 采用数组 + 链表或红黑树；</p><p><strong>2.链表插入方式：</strong>JDK 1.7 采用头插法，JDK 1.8 采用尾插法；</p><p><strong>3.扩容rehash：</strong> JDK 1.7 扩容时需要对原数组中的元素进行重新 hash 定位在新数组的位置，JDK 1.8 不需要重新通过 hash 函数计算位置，新的位置不变或索引 + 新增容量大小；</p><p><strong>4.扩容时机：</strong>JDK 1.7 先判断是否需要扩容再插入，JDK 1.8 先进行插入，插入完成再判断是否需要扩容；</p><p><strong>5.散列函数：</strong>JDK 1.7 做了四次移位和四次异或，JDK 1.8 只做一次。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="ConcurrentHashMap-底层具体实现知道吗"><a href="#ConcurrentHashMap-底层具体实现知道吗" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗?"></a>ConcurrentHashMap 底层具体实现知道吗?</h3><p>JDK 1.8 之前：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310122144862.jpg"></p><p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。<code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p><p>JDK 1.8 之后：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310122202709.jpg"></p><p>JDK 1.8 中<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。JDK 1.8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p><blockquote><p><strong>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同?</strong></p><p><strong>1. 线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK 1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p><p><strong>2. Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK 1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p><p><strong>3. 并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p></blockquote><h3 id="为什么要用ConcurrentHashMap"><a href="#为什么要用ConcurrentHashMap" class="headerlink" title="为什么要用ConcurrentHashMap?"></a>为什么要用ConcurrentHashMap?</h3><p><code>HashMap</code> 是<strong>线程不安全</strong>的。</p><blockquote><p><strong>为什么说 HashMap 线程不安全?</strong></p><p>1.多线程下扩容死循环。JDK 1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK 1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</p><p>2.多线程的 put 可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK 1.7 和 JDK 1.8 中都存在。</p><p>3.put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出 threshold 而导致 rehash，线程 2 此时执行 get，有可能导致这个问题。此问题在 JDK 1.7 和 JDK 1.8 中都存在。</p></blockquote><p><code>HashTable</code> 是<strong>线程安全</strong>的，但是 <code>HashTable</code> 的效率太低了。</p><blockquote><p><strong>为什么说 HashTable 效率低下?</strong></p><p><code>HashTable</code> 使用 <code>synchronized</code> 关键字来保证线程安全。当一个线程访问 <code>HashTable</code> 的同步方法，其他线程也访问 <code>HashTable</code> 的同步方法就会进入阻塞或轮询状态。可以理解 <code>HashTable</code> 只有一把锁，所有的线程不管做什么，都是竞争这一把锁。</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>本文仅用于个人学习，不涉及出售或倒卖</p><p>文中部分引用 JavaGuide 博主网站中的内容，<a href="https://javaguide.cn/">了解详情戳此处</a>。</p><p>文中部分引用 keyjane 作者 Github 空间中的内容。<a href="https://github.com/keyjane/2019_campus_apply/blob/master/notes/JavaArchitecture/02%20Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.md#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE">了解详情戳此处</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础篇</title>
    <link href="/posts/4c564f26.html"/>
    <url>/posts/4c564f26.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 01, 2023</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的几种基本数据类型了解吗"><a href="#Java-中的几种基本数据类型了解吗" class="headerlink" title="Java 中的几种基本数据类型了解吗?"></a>Java 中的几种基本数据类型了解吗?</h3><p>Java 中有 8 种基本数据类型，分别为：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>blooean</code>。</p><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310011802831.png"></p><p>可以看到，像 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>能表示的最大正数都减 1 了，这是因为在二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p><h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别?"></a>基本类型和包装类型的区别?</h3><p>Java 的每个基本类型都对应了一个包装类型，即：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><p><strong>区别：</strong></p><p>1.包装类型可以为 <code>null</code>，而基本类型不可以 。</p><p>2.包装类型可用于泛型，而基本类型不可以 。</p><p>3.基本类型比包装类型更高效（基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用）。</p><p>4.相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p>5.对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h3 id="自动装箱与拆箱了解吗"><a href="#自动装箱与拆箱了解吗" class="headerlink" title="自动装箱与拆箱了解吗?"></a>自动装箱与拆箱了解吗?</h3><p>有了基本类型和包装类型，肯定有些时候要在它们之间进行转换。</p><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p><p>在 JDK 1.5之前，需要开发人员手动进行装拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 手动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue(); <span class="hljs-comment">// 手动拆箱</span><br></code></pre></td></tr></table></figure><p>在 JDK 1.5之后，为了简化开发人员的工作 Java 提供了自动装拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">// 自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">// 自动拆箱</span><br><br>=&gt;<br>    <br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></td></tr></table></figure><p>也就是说，自动装箱是调用包装类的<code>valueOf()</code>方法完成的；自动拆箱是调用 <code>xxxValue()</code> 方法完成的。</p><p><strong>注意：</strong>应该尽量避免不必要的装拆箱操作，因为频繁装拆箱会严重影响系统的性能。</p><h3 id="包装类型的缓存机制了解吗"><a href="#包装类型的缓存机制了解吗" class="headerlink" title="包装类型的缓存机制了解吗?"></a>包装类型的缓存机制了解吗?</h3><p>Java 基本数据类型的包装类型（除了Float和Double）都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回<code>true</code>或<code>false</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 下面的代码的输出结果是 true 还是 false?</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>System.out.println(i==j);<br></code></pre></td></tr></table></figure><p><code>Integer i = 10</code>这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i = Integer.valueOf(10)</code> 。因此，<code>i</code> 直接使用的是缓存中的对象。而<code>Integer j = new Integer(10)</code> 会直接创建新的对象。所以答案是<code>false</code>。</p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="Final关键字有什么作用"><a href="#Final关键字有什么作用" class="headerlink" title="Final关键字有什么作用?"></a>Final关键字有什么作用?</h3><p>1.被final修饰的类不可以被继承 。</p><p>2.被final修饰的方法不可以被重写 。</p><p>3.被final修饰的变量不可以被改变。</p><p>4.被final修饰不可变的是变量的引用，而不是引用指向的内容， 引用指向的内容是可以改变的。</p><h3 id="什么是重载（Overload）和重写（Override）"><a href="#什么是重载（Overload）和重写（Override）" class="headerlink" title="什么是重载（Overload）和重写（Override）?"></a>什么是重载（Overload）和重写（Override）?</h3><p><strong>重载：</strong>发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分 。</p><p><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，子类方法返回值小于等于父类，抛出的异常范围小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明；构造方法无法被重写。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310012252672.png"></p><h3 id="知道-和-equals-的区别吗"><a href="#知道-和-equals-的区别吗" class="headerlink" title="知道&#x3D;&#x3D; 和 equals() 的区别吗?"></a>知道&#x3D;&#x3D; 和 equals() 的区别吗?</h3><p><code>==</code>  的作用是判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象。(对于基本数据类型 <code>==</code> 比较的是值，对于引用数据类型 <code>==</code> 比较的是对象的内存地址)。</p><blockquote><p>因为 Java 只有值传递，所以对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Object类中的equals()方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>     <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><p>1.类没有重写 <code>equals()</code>方法：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是<code>Object</code>类中的<code>equals()</code>方法。</p><p>2.类重写了 <code>equals()</code>方法：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</p><h3 id="hashCode三连问"><a href="#hashCode三连问" class="headerlink" title="hashCode三连问"></a>hashCode三连问</h3><h4 id="hashCode-有什么用"><a href="#hashCode-有什么用" class="headerlink" title="hashCode()有什么用?"></a>hashCode()有什么用?</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。散列表存储的是键值对(key-value)，它的特点是：<strong>能根据”键”快速的检索出对应的”值”，这其中就利用到了散列码（可以快速找到所需要的对象）。</strong></p><h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode?"></a>为什么要有 hashCode?</h4><p>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</p><p>如果两个对象的<code>hashCode</code> 值相等，那这两个对象也不一定相等（哈希碰撞）。</p><blockquote><p><strong>哈希碰撞：</strong><code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p></blockquote><p>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p><h4 id="为什么重写-equals-时必须重写-hashCode-方法"><a href="#为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法?"></a>为什么重写 equals() 时必须重写 hashCode() 方法?</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><h3 id="String、StringBuffer、StringBuilder-的区别"><a href="#String、StringBuffer、StringBuilder-的区别" class="headerlink" title="String、StringBuffer、StringBuilder 的区别?"></a>String、StringBuffer、StringBuilder 的区别?</h3><p><strong>可变性：</strong><code>String</code>类中使用字符数组保存字符串，所以<code>string</code>对象是不可变的。<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><blockquote><p><strong>String 为什么是不可变的?</strong></p><p>1.保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</p><p>2.<code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p></blockquote><p><strong>线程安全性：</strong><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能：</strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><blockquote><p><strong>总结：</strong></p><p>1.操作少量的数据: 适用 <code>String</code></p><p>2.单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></p><p>3.多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></p></blockquote><h3 id="知道泛型吗-有什么作用"><a href="#知道泛型吗-有什么作用" class="headerlink" title="知道泛型吗?有什么作用?"></a>知道泛型吗?有什么作用?</h3><p><strong>泛型（Generics）</strong> 是 JDK 5 引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p><h3 id="知道注解吗-注解的解析方法有哪几种"><a href="#知道注解吗-注解的解析方法有哪几种" class="headerlink" title="知道注解吗?注解的解析方法有哪几种?"></a>知道注解吗?注解的解析方法有哪几种?</h3><p><strong>注解（Annotation）</strong>是 JDK 5 引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。JDK 提供了很多内置的注解（比如 <code>@Override</code>、<code>@Deprecated</code>），同时我们还可以自定义注解。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Override</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注解只有被解析之后才会生效，常见的<strong>解析方法</strong>有两种：</p><p><strong>1.编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</p><p><strong>2.运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</p><h3 id="知道反射吗-有什么优缺点"><a href="#知道反射吗-有什么优缺点" class="headerlink" title="知道反射吗?有什么优缺点?"></a>知道反射吗?有什么优缺点?</h3><p><strong>反射（Reflection）</strong>是指在运行状态中，对于任意一个类都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为 Java 语言的反射。</p><p><strong>优点：</strong>可以在运行期进行类型的判断，动态加载类，提高代码灵活度，为各种框架提供开箱即用的功能提供了便利。</p><p><strong>缺点：</strong>增加了安全问题（比如可以无视泛型参数的安全检查），性能瓶颈。</p><blockquote><p>反射的应用场景</p><p>1.在我们的项目中经常会使用反射 + 自定义注解的方式去实现一些功能，比如：在前后端交互的时候, 后端 Long 类型返回前端后会产生精度丢失 , 我们的处理方式就是在服务端, 通过配置修改 Jackson 的序列化规则, 将一些 Long 类型字段转化为字符串返回给前端, 这个时候我们自定义了一个@IdEncrpt注解 , 通过反射获取类的属性, 判断属性上是否添加了@IdEncrpt注解, 如果添加了 , 就会通过反射获取属性值, 转化为字符串。</p><p>2.像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制（这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射）。</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>本文仅用于个人学习，不涉及出售或倒卖</p><p>文中部分引用 JavaGuide 博主网站中的内容，<a href="https://javaguide.cn/">了解详情戳此处</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
