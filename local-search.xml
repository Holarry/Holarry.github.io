<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/posts/c24675b4.html"/>
    <url>/posts/c24675b4.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 29, 2023</p><h2 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h2><h3 id="MySQL字段类型"><a href="#MySQL字段类型" class="headerlink" title="MySQL字段类型"></a>MySQL字段类型</h3><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202310292108367.png"></p><h3 id="整数类型的-UNSIGNED-属性有什么用"><a href="#整数类型的-UNSIGNED-属性有什么用" class="headerlink" title="整数类型的 UNSIGNED 属性有什么用?"></a>整数类型的 UNSIGNED 属性有什么用?</h3><p>MySQL 中的整数类型可以使用可选的 <code>UNSIGNED</code> 属性来表示不允许负值的无符号整数。使用 <code>UNSIGNED</code> 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。例如， <code>TINYINT UNSIGNED</code> 类型的取值范围是 0 ~ 255，而普通的 <code>TINYINT</code> 类型的值范围是 -128 ~ 127。<code>INT UNSIGNED</code> 类型的取值范围是 0 ~ 4294967295，而普通的 <code>INT</code> 类型的值范围是 2147483648 ~ 2147483647。</p><p>对于从 0 开始递增的 ID 列，使用 <code>UNSIGNED</code> 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h3 id="CHAR-和-VARCHAR-有什么区别"><a href="#CHAR-和-VARCHAR-有什么区别" class="headerlink" title="CHAR 和 VARCHAR 有什么区别?"></a>CHAR 和 VARCHAR 有什么区别?</h3><p>1.<strong>CHAR 是定长字符串(如果插入数据的长度小于 char 的固定长度时，则用空格填充)，VARCHAR 是变长字符串。</strong></p><p>2.CHAR 的存取速度比 VARCHAR 要快得多。</p><p>3.CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</p><h3 id="DECIMAL-和-FLOAT-DOUBLE-的区别是什么"><a href="#DECIMAL-和-FLOAT-DOUBLE-的区别是什么" class="headerlink" title="DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么?"></a>DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么?</h3><p><strong>DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</strong></p><p>DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。</p><h3 id="DATETIME-和-TIMESTAMP-有什么区别"><a href="#DATETIME-和-TIMESTAMP-有什么区别" class="headerlink" title="DATETIME 和 TIMESTAMP 有什么区别?"></a>DATETIME 和 TIMESTAMP 有什么区别?</h3><p>1.DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区。</p><p>2.DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节。</p><p>3.DATETIME 的日期范围是 <code>1000-01-01 00:00:00.000000</code> 到 <code>9999-12-31 23:59:59.999999</code>；TIMESTAMP 的时间范围是<code>1970-01-01 00:00:01.000000</code> UTC 到 <code>2038-01-09 03:14:07.999999</code> UTC。</p><p>4.DATETIME 的默认值为 NULL；TIMESTAMP 的字段默认不为空(NOT NULL)，默认值为当前时间(CURRENT_TIMESTAMP)。</p><h3 id="NULL-和-‘’-有什么区别"><a href="#NULL-和-‘’-有什么区别" class="headerlink" title="NULL 和 ‘’ 有什么区别?"></a>NULL 和 ‘’ 有什么区别?</h3><p>1.<code>&#39;&#39;</code> 的长度是 0，是不占用空间的；<code>NULL</code> 是需要占用空间的。</p><p>2.<code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</p><p>3.查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而 <code>&#39;&#39;</code> 是可以使用这些比较运算符的。</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h3><p><strong>概述：</strong>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作<strong>要么同时成功，要么同时失败</strong>。</p><p><strong>四大特性(ACID)：</strong></p><p>1.<strong>原子性(<code>Atomicity</code>):</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。</p><p>2.<strong>一致性(<code>Consistency</code>):</strong> 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。</p><p>3.<strong>隔离性(<code>Isolation</code>):</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。</p><p>4.<strong>持久性(<code>Durability</code>):</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><ul><li><strong>脏读：一个事务读到另一个事务还没有提交的数据。</strong>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据。</li><li><strong>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同。</strong>指在一个事务内多次读同一数据，在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况。</li><li><strong>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影”。</strong>幻读与不可重复读类似，它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录。</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center"><strong>Read uncommitted</strong></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center"><strong>Read committed</strong></td><td align="center">x</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center"><strong>Repeatable Read(默认)</strong></td><td align="center">x</td><td align="center">x</td><td align="center">✓</td></tr><tr><td align="center"><strong>Serializable</strong></td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 开启事务<br>start transaction;<br>-- 提交事务<br>commit;<br>-- 回滚事务<br>rollback;<br><br>-- 查看事务隔离级别<br>select @@transaction_isolation;<br>-- 设置事务隔离级别<br>set session transaction isolation level&#123;Read uncommitted | Read committed | Repeatable Read | Serializable&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：事务隔离级别越高，数据越安全，但是性能更低。</strong></p><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><h3 id="MySQL-支持哪几种存储引擎"><a href="#MySQL-支持哪几种存储引擎" class="headerlink" title="MySQL 支持哪几种存储引擎?"></a>MySQL 支持哪几种存储引擎?</h3><h4 id="InnoDB-引擎"><a href="#InnoDB-引擎" class="headerlink" title="InnoDB 引擎"></a>InnoDB 引擎</h4><p><strong>概述:</strong> InnoDB 是一种兼顾<strong>高可靠性</strong>和<strong>高性能</strong>的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是 MySQL 默认的存储引擎。</p><p><strong>特点:</strong> </p><ul><li>支持<strong>事务</strong></li><li>支持<strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>，保证数据的完整性和正确性</li></ul><p><strong>逻辑存储结构:</strong> </p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202310301547314.png"></p><ul><li>表空间: InnoDB 存储引擎逻辑结构的最高层，ibd 文件其实就是表空间文件，在表空间中可以包含多个 Segment 段。</li><li>段: 表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB 中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 </li><li>区: 区是表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为 16K，即一个区中一共有 64 个连续的页。</li><li>页: 页是组成区的最小单元，页也是 InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行: InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段。</li></ul><h4 id="MyISAM-引擎"><a href="#MyISAM-引擎" class="headerlink" title="MyISAM 引擎"></a>MyISAM 引擎</h4><p><strong>概述:</strong> MyISAM 是 MySQL 早期的默认存储引擎。</p><p><strong>特点:</strong> </p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><h4 id="Memory-引擎"><a href="#Memory-引擎" class="headerlink" title="Memory 引擎"></a>Memory 引擎</h4><p><strong>概述:</strong> Memory 引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p><strong>特点:</strong> 内存存放，hash索引(默认)。</p><blockquote><p><strong>InnoDB 引擎与 MyISAM 引擎的区别?</strong></p><p>1.InnoDB 支持事务，而 MyISAM 不支持。 </p><p>2.InnoDB 支持行锁和表锁，而 MyISAM 仅支持表锁，不支持行锁。</p><p>3.InnoDB 支持外键，而 MyISAM 不支持。</p></blockquote><h3 id="如何选择存储引擎"><a href="#如何选择存储引擎" class="headerlink" title="如何选择存储引擎?"></a>如何选择存储引擎?</h3><ul><li>InnoDB: 是 MySQL 的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li></ul><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引?"></a>什么是索引?</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p><strong>优点</strong>:</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong>:</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><blockquote><p><strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p></blockquote><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311082054864.png"></p><p>1.按照基本使用划分:</p><ul><li>主键索引: InnoDB 主键是默认的索引，数据列不允许重复，不允许为 NULL 值。</li><li>唯一索引: 数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。</li><li>普通索引: 基本的索引类型，没有唯一性的限制，允许为 NULL 值。</li><li>组合索引: 多列值组成一个索引，用于组合搜索，效率大于索引合并。</li></ul><p>2.按照数据结构划分:</p><ul><li>哈希索引: 哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中。如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了 hash 冲突（也称为 hash 碰撞），可以通过链表来解决。</li><li>B+树索引: MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。</li></ul><p>3.按照物理存储划分:</p><ul><li>聚簇索引(聚集索引): 索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li><li>非聚簇索引(非聚集索引): 索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li></ul><h3 id="主键索引和二级索引"><a href="#主键索引和二级索引" class="headerlink" title="主键索引和二级索引"></a>主键索引和二级索引</h3><ul><li>主键索引: 数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 <code>null</code>，不能重复。</li><li>二级索引: 又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。唯一索引，普通索引，前缀索引等索引属于二级索引。</li></ul><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><p><strong>聚集索引: 即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚集索引。</strong>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code> 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p><strong>非聚集索引: 即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚集索引。</strong>MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚集索引。</p><blockquote><p>回表查询: 先到非聚集索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p></blockquote><p><strong>聚集索引的优缺点:</strong></p><p><strong>优点:</strong></p><p><strong>1.查询速度非常快</strong>: 聚集索引的查询速度非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚集索引，聚集索引少了一次读取数据的 IO 操作。</p><p><strong>2.对排序查找和范围查找优化</strong>: 聚集索引对于主键的排序查找和范围查找速度非常快。</p><p><strong>缺点:</strong></p><p><strong>1.依赖于有序的数据</strong>: 因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度比较慢。</p><p><strong>2.更新代价大</strong>: 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</p><p><strong>非聚簇索引的优缺点:</strong></p><p>**优点: **非聚集索引的更新代价没有聚集索引那么大，非聚集索引的叶子节点是不存放数据的。</p><p><strong>缺点:</strong></p><p><strong>1.依赖于有序的数据</strong>: 跟聚集索引一样，非聚集索引也依赖于有序的数据。</p><p><strong>2.可能会二次查询(回表)</strong>: 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</p><h3 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h3><p><strong>覆盖索引: 即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p><strong>联合索引:</strong> 使用表中的多个字段创建索引，就是<strong>联合索引</strong>，也叫<strong>组合索引</strong>或<strong>复合索引</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 为name、age、gender创建联合索引<br>CREATE INDEX idx_user_name_age_gender ON tb_user(name,age,gender);<br></code></pre></td></tr></table></figure><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。最左匹配原则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p><p>比如，如果创建了一个 (a, b, c) 联合索引，相当于创建了（a）、(a, b) 和 (a, b, c) 三个索引。如果查询条件是以下这几种，就可以利用联合索引: </p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效: </p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>上面这些查询条件之所以会失效，是因为 (a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>1.在索引列上进行计算、函数等操作时，索引失效。</p><p>对 tb_user 表的 phone 字段创建索引 idx_user_phone。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311131242246.png"></p><p>从图中可以看出，第一条 SQL 使用了 idx_user_phone 索引，第二条 SQL 没有使用索引。</p><p>2.字符串类型字段使用时，不加引号，索引将失效。(如果字符串不加单引号，对于查询结果没什么影响，但是数据库存在隐式类型转换，索引将失效)</p><p>删除之前的索引，对 tb_user 表的 profession,age,status 字段创建联合索引 idx_user_pro_age_sta。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311131247758.png"></p><p>从图中可以看出，两条 SQL 都使用了 idx_user_pro_age_sta 索引，第一条 SQL 使用的索引的长度为54，但第二条 SQL 使用的索引的长度为49，所以第二条 SQL 中的 status 字段的索引失效了。</p><p>3.在 like 模糊查询中，在关键字后面加%，索引生效。而如果在关键字前面加了%，索引失效。</p><p>删除之前的索引，对 tb_user 表的 profession,age,status 字段创建联合索引 idx_user_pro_age_sta。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311131253148.png"></p><p>从图中可以看出，只有第一条 SQL 使用了 idx_user_pro_age_sta 索引。</p><p>4.查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到。</p><p>删除之前的索引，对 tb_user 表的 phone 字段创建索引 idx_user_phone。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311131259016.png"></p><p>从图中可以看出，两条 SQL 都没有使用索引。由于 age 没有索引，所以即使 id、phone 有索引，索引也会失效。</p><p>对age建立索引之后，再次执行上述的SQL语句: </p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311131302525.png"></p><p>可以看出，<strong>当or连接的条件，左右两侧字段都有索引时，索引才会生效。</strong></p><p>5.MySQL 优化器估计使用全表扫描要比使用索引快,则不使用索引。</p><h3 id="索引设计建议"><a href="#索引设计建议" class="headerlink" title="索引设计建议"></a>索引设计建议</h3><ul><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ul><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><h4 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h4><p>通过 <code>show [session|global] status</code> 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 的访问频次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># session 查看当前会话;<br># global 查询全局数据;<br>SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311131310205.png"></p><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL 语句的日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 开启MySQL慢日志查询开关<br>slow_query_log=1<br># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>long_query_time=2<br></code></pre></td></tr></table></figure><h4 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h4><p><code>show profiles</code> 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 开启profile<br>SET profiling = 1;<br># 开启后，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了<br># 执行如下的SQL语句：<br>select * from tb_user;<br>select * from tb_user where id = 1;<br>select * from tb_user where name = &#x27;白起&#x27;;<br>select count(*) from user;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看每一条SQL的耗时基本情况<br>show profiles;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311131314104.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看指定query_id的SQL语句各个阶段的耗时情况<br>show profile for query query_id;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311131315667.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看指定query_id的SQL语句CPU的使用情况<br>show profile cpu for query query_id;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202311131315859.png"></p><h4 id="explain-desc"><a href="#explain-desc" class="headerlink" title="explain [desc]"></a>explain [desc]</h4><p><code>EXPLAIN</code> 或者 <code>DESC</code> 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 直接在select语句之前加上关键字 explain / desc<br>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">SELECT 查询的序列标识符</td></tr><tr><td align="center">select_type</td><td align="center">SELECT 关键字对应的查询类型</td></tr><tr><td align="center">table</td><td align="center">用到的表名</td></tr><tr><td align="center">partitions</td><td align="center">匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td align="center">type</td><td align="center">连接类型，性能由好到差为NULL、system、const、eq_ref、ref、range、index、all</td></tr><tr><td align="center">possible_keys</td><td align="center">可能用到的索引</td></tr><tr><td align="center">key</td><td align="center">实际用到的索引</td></tr><tr><td align="center">key_len</td><td align="center">所选索引的长度</td></tr><tr><td align="center">ref</td><td align="center">当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td align="center">rows</td><td align="center">预计要读取的行数</td></tr><tr><td align="center">filtered</td><td align="center">按表条件过滤后，留存的记录数的百分比</td></tr><tr><td align="center">Extra</td><td align="center">附加信息</td></tr></tbody></table><p><strong>type:</strong></p><p>system: 如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</p><p>const: 表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</p><p>eq_ref: 当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</p><p>ref: 使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</p><p>index_merge: 当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</p><p>range: 对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</p><p>index: 查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</p><p>all: 全表扫描。</p><p><strong>Extra:</strong> 这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。</p><p>Using filesort: 在排序时使用了外部的索引排序，没有用到表内索引进行排序。</p><p>Using temporary: MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</p><p>Using index: 表明查询使用了覆盖索引，不用回表，查询效率非常高。</p><p>Using index condition: 表示查询优化器选择使用了索引条件下推这个特性。</p><p>Using where: 表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</p><p>Using join buffer (Block Nested Loop): 连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</p><p><strong>当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/posts/1bff3c65.html"/>
    <url>/posts/1bff3c65.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 27, 2023</p><h3 id="什么是-MyBatis"><a href="#什么是-MyBatis" class="headerlink" title="什么是 MyBatis?"></a>什么是 MyBatis?</h3><p>MyBatis 是一个半 ORM(对象关系映射) 框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 SQL，可以严格控制 SQL执行性能，灵活度高。MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><h3 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{} 和 ${} 的区别是什么?"></a>#{} 和 ${} 的区别是什么?</h3><ul><li><code>#&#123;&#125;</code>是占位符，预编译处理；<code>$&#123;&#125;</code>是拼接符，没有预编译处理。(MyBatis在处理<code>#&#123;&#125;</code>时，<code>#&#123;&#125;</code>传入参数是以字符串传入，会将 SQL 中的<code>#&#123;&#125;</code>替换为 ? 号，调用 <code>PreparedStatement</code> 的 <code>set</code> 方法来赋值。)</li><li><code>#&#123;&#125;</code> 可以有效的防止 SQ L注入，提高系统安全性；<code>$&#123;&#125;</code> 不能防止 SQL 注入。</li><li><code>#&#123;&#125;</code> 的变量替换是在 DBMS 中；<code>$&#123;&#125;</code> 的变量替换是在 DBMS 外。</li></ul><h3 id="怎么在-mapper-中传递多个参数"><a href="#怎么在-mapper-中传递多个参数" class="headerlink" title="怎么在 mapper 中传递多个参数?"></a>怎么在 mapper 中传递多个参数?</h3><p><strong>1.顺序传参法:</strong> <code>#&#123;&#125;</code>里面的数字代表传入参数的顺序，这种方法<strong>不建议使用</strong>，SQL 层表达不直观，一旦顺序调整容易出错。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span> selectUser(String <span class="hljs-type">name</span>, <span class="hljs-type">int</span> deptId);<br><br>&lt;<span class="hljs-keyword">select</span> id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span><br>    <span class="hljs-keyword">where</span> user_name = #&#123;<span class="hljs-number">0</span>&#125; <span class="hljs-keyword">and</span> dept_id = #&#123;<span class="hljs-number">1</span>&#125;<br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>2.<code>@Param</code>注解传参法:</strong> <code>#&#123;&#125;</code>里面的名称对应的是注解 <code>@Param</code> 括号里面修饰的名称，这种方法在参数不多的情况<strong>建议使用</strong>。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span> selectUser(@Param(&quot;userName&quot;) String <span class="hljs-type">name</span>, <span class="hljs-type">int</span> @Param(&quot;deptId&quot;) deptId);<br><br>&lt;<span class="hljs-keyword">select</span> id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span><br>    <span class="hljs-keyword">where</span> user_name = #&#123;userName&#125; <span class="hljs-keyword">and</span> dept_id = #&#123;deptId&#125;<br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>3.Map传参法:</strong> <code>#&#123;&#125;</code>里面的名称对应的是 Map 里面的 key 名称，这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">selectUser</span>(<span class="hljs-params">Map&lt;String, Object&gt; <span class="hljs-keyword">params</span></span>)</span>;<br><br>&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;selectUser&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> user<br>    <span class="hljs-keyword">where</span> user_name = <span class="hljs-meta">#&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>4.Java Bean传参法:</strong> <code>#&#123;&#125;</code>里面的名称对应的是 Java Bean 类里面的成员属性，这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，<strong>推荐使用</strong>。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span> selectUser(<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>);<br><br>&lt;<span class="hljs-keyword">select</span> id=&quot;selectUser&quot; parameterType=&quot;com.holary.pojo.User&quot; resultMap=&quot;UserResultMap&quot;&gt;<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span><br>    <span class="hljs-keyword">where</span> user_name = #&#123;userName&#125; <span class="hljs-keyword">and</span> dept_id = #&#123;deptId&#125;<br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="实体类属性名和表中字段名不一样，怎么解决"><a href="#实体类属性名和表中字段名不一样，怎么解决" class="headerlink" title="实体类属性名和表中字段名不一样，怎么解决?"></a>实体类属性名和表中字段名不一样，怎么解决?</h3><p>1.通过在查询的 SQL 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p><p>2.通过 ResultMap 来映射字段名和实体类属性名。</p><h3 id="MyBatis是否支持延迟加载"><a href="#MyBatis是否支持延迟加载" class="headerlink" title="MyBatis是否支持延迟加载?"></a>MyBatis是否支持延迟加载?</h3><p>MyBatis支持 <strong>association</strong> 关联对象和 <strong>collection</strong> 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false</code>。</p><h3 id="MyBatis如何获取-insert-新增数据的id"><a href="#MyBatis如何获取-insert-新增数据的id" class="headerlink" title="MyBatis如何获取 insert 新增数据的id?"></a>MyBatis如何获取 insert 新增数据的id?</h3><p>使用 <code>keyProperty</code> 和 <code>useGeneratedKeys </code> 可以获取到自增主键值。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id=&quot;insert&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot;&gt;<br>    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-type">name</span>, age, birthday, id_card)<br>    <span class="hljs-keyword">values</span> (#&#123;<span class="hljs-type">name</span>&#125;, #&#123;age&#125;, #&#123;birthday&#125;, #&#123;idCard&#125;)<br>&lt;/<span class="hljs-keyword">insert</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">userMapper.insert(user);<br>user.getId();<br></code></pre></td></tr></table></figure><h3 id="MyBatis如何执行批量操作"><a href="#MyBatis如何执行批量操作" class="headerlink" title="MyBatis如何执行批量操作?"></a>MyBatis如何执行批量操作?</h3><p>使用 <code>foreach</code> 标签，<code>foreach</code> 的主要用在构建 in 条件中，它可以在 SQL 语句中进行迭代一个集合。<code>foreach</code> 标签的属性主要有item、index、collection、open、separator、close。</p><ul><li>item     表示集合中每一个元素进行迭代时的别名，随便起的变量名</li><li>index    指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用</li><li>open     表示该语句以什么开始，常用”(“</li><li>separator 表示在每次进行迭代之间以什么符号作为分隔符，常用”,”</li><li>close    表示以什么结束，常用”)”</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id=&quot;addUsersBatch&quot;&gt;<br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span>(<span class="hljs-type">name</span>,age,gender,addr)<br>    <span class="hljs-keyword">VALUES</span><br>    &lt;<span class="hljs-keyword">foreach</span> collection=&quot;userList&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;<br>        (#&#123;<span class="hljs-keyword">user</span>.name&#125;,#&#123;<span class="hljs-keyword">user</span>.age&#125;,#&#123;<span class="hljs-keyword">user</span>.gender&#125;,#&#123;<span class="hljs-keyword">user</span>.addr&#125;)<br>    &lt;/<span class="hljs-keyword">foreach</span>&gt;<br>&lt;/<span class="hljs-keyword">insert</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="知道-MyBatis-的缓存机制吗"><a href="#知道-MyBatis-的缓存机制吗" class="headerlink" title="知道 MyBatis 的缓存机制吗?"></a>知道 MyBatis 的缓存机制吗?</h3><p><strong>一级缓存:</strong> 基于 SqlSession 级别的缓存,各个 SqlSession 之间的缓存相互隔离，当 <code>Session flush</code> 或 <code>close</code> 之后，该 SqlSession 中的所有 Cache 就将清空，MyBatis 默认开启一级缓存。</p><p><strong>二级缓存:</strong> 基于 SqlSessionFactory 的 NameSpace 级别缓存，可以在多个 SqlSession 之间共享，并且可自定义存储源，如Ehcache。默认不开启二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 配置cacheEnabled为true<br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 开启二级缓存 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br># 在映射配置文件中配置cache相关配置<br><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span> <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span> <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;1024&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/posts/6c92115f.html"/>
    <url>/posts/6c92115f.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 22, 2023</p><h2 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a>Spring 基础</h2><h3 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h3><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p><strong>Spring 特性：</strong></p><p>1.IOC 和 DI 的支持：Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现高内聚低耦合的设计理念。</p><p>2.AOP 的支持：Spring 提供了面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p><p>3.声明式事务的支持：支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。</p><p>4.快捷测试的支持：Spring 对 Junit 提供支持，可以通过注解快捷地测试 Spring 程序。</p><p>5.快速集成功能：方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p><p>6.复杂 API 模板封装：Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。</p><h3 id="Spring-框架有哪些模块"><a href="#Spring-框架有哪些模块" class="headerlink" title="Spring 框架有哪些模块?"></a>Spring 框架有哪些模块?</h3><p>1.<strong>Spring Core：</strong>Spring Core是Spring框架的核心模块，提供了IoC（Inversion of Control）容器的实现和支持。它负责创建、配置和管理应用程序中的对象，并通过依赖注入的方式解耦组件之间的依赖关系。</p><p>2.<strong>Spring AOP：</strong>Spring AOP模块实现了面向切面编程（AOP）的支持。它允许开发者通过定义切点和切面，将横切关注点（如日志记录、性能监控等）与业务逻辑分离，从而提高代码的模块化和可维护性。</p><p>3.<strong>Spring Web MVC：</strong>Spring Web MVC是Spring框架的Web应用程序开发模块。它提供了一种基于MVC（Model-View-Controller）的架构，用于构建灵活、可扩展的Web应用程序。开发者可以使用注解或配置文件定义控制器、视图和模型，并实现Web请求的处理和响应。</p><p>4.<strong>Spring WebFlux：</strong>Spring WebFlux是Spring框架的响应式Web开发模块。它基于反应式编程模型，提供了一种异步、非阻塞的方式处理Web请求。开发者可以使用注解或函数式编程风格定义处理器函数，并利用响应式流处理请求和响应。</p><p>5.<strong>Spring Web：</strong>Spring Web模块是Spring框架的Web应用程序支持模块，提供了与Servlet API和其他Web相关技术的集成。它包括与Web安全、文件上传、WebSockets等相关的功能和工具，帮助开发者构建全功能的Web应用程序。</p><p>6.<strong>Spring DAO：</strong>Spring DAO模块提供了对数据访问对象（DAO）的支持。它简化了与数据库的交互，提供了一组抽象和实现，用于执行CRUD操作、批处理、存储过程调用等。开发者可以集成各种数据访问技术（如JDBC、Hibernate、JPA等）来实现灵活和可扩展的数据访问层。</p><p>7.<strong>Spring ORM：</strong>Spring ORM模块用于集成和支持各种对象关系映射（ORM）框架，如Hibernate、JPA等。它提供了事务管理、异常转换和对象关系映射等功能，简化了与关系型数据库的交互。</p><p>8.<strong>Spring Context：</strong>Spring Context是Spring框架的核心模块之一，实现了IoC容器的功能。它负责管理和组织应用程序中的各个组件，包括Bean管理、依赖注入、生命周期管理、事件机制等。Spring Context提供了一个上下文环境，使得开发者能够更方便地构建和管理应用程序。</p><h3 id="Spring-框架有哪些常用注解"><a href="#Spring-框架有哪些常用注解" class="headerlink" title="Spring 框架有哪些常用注解?"></a>Spring 框架有哪些常用注解?</h3><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202310221544050.png"></p><p>Web: </p><ul><li>@Controller：组合注解（组合了@Component 注解），应用在 MVC 层（控制层）。</li><li>@RestController：该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</li><li>@RequestMapping：用于映射 Web 请求，包括访问路径和参数。如果是 Restful 风格接口，还可以根据请求类型使用不同的注解：<ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li></ul></li><li>@ResponseBody：支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。</li><li>@RequestBody：允许 request 的参数在 request 体中，而不是在直接连接在地址后面。</li><li>@PathVariable：用于接收路径参数，比如 <code>@RequestMapping(&quot;/users/&#123;id&#125;&quot;)</code>申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。</li></ul><p>容器: </p><ul><li>@Component：表示一个带注释的类是一个“组件”，成为 Spring 管理的 Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component 还是一个元注解。</li><li>@Service：组合注解（组合了@Component 注解），应用在 service 层（业务逻辑层）。</li><li>@Repository：组合注解（组合了@Component 注解），应用在 dao 层（数据访问层）。</li><li>@Autowired：Spring 提供的工具（由 Spring 的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</li><li>@Qualifier：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解</li><li>@Configuration：声明当前类是一个配置类（相当于一个 Spring 配置的 xml 文件）</li><li>@Value：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 <code>#&#123;&#125; 跟 \$&#123;&#125;</code> 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。</li><li>@Bean：注解在方法上，声明当前方法的返回值为一个 Bean。返回的 Bean 对应的类中可以定义 init()方法和 destroy()方法，然后在<code>@Bean(initMethod=&quot;init&quot;,destroyMethod=&quot;destroy&quot;)</code>定义，在构造之后执行 init，在销毁之前执行 destroy。</li><li>@Scope:定义我们采用什么模式去创建 Bean（方法上，得有@Bean） 其设置类型包括：Singleton、Prototype、Request、Session、GlobalSession。</li></ul><p>AOP: </p><p>@Aspect:声明一个切面（类上） 使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。</p><ul><li><code>@After</code> ：在方法执行之后执行（方法上）。</li><li><code>@Before</code>：在方法执行之前执行（方法上）。</li><li><code>@Around</code>：在方法执行之前与之后执行（方法上）。</li><li><code>@PointCut</code>：声明切点 在 java 配置类中使用@EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上）。</li></ul><p>事务: </p><p>@Transactional：在要开启事务的方法上使用@Transactional 注解，即可声明式开启事务。</p><h3 id="Spring-框架中应用了哪些设计模式"><a href="#Spring-框架中应用了哪些设计模式" class="headerlink" title="Spring 框架中应用了哪些设计模式?"></a>Spring 框架中应用了哪些设计模式?</h3><p>1.<strong>工厂模式</strong>: Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</p><p>2.<strong>代理模式</strong>: Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</p><p>3.<strong>单例模式</strong>: Spring 中的 Bean 默认都是单例的，这样有利于容器对 Bean 的管理。</p><p>4.<strong>模板模式</strong>: Spring 中 JdbcTemplate、RestTemplate 等以 Template 结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模5.。</p><p>5.<strong>观察者模式</strong>: Spring 事件驱动模型就是观察者模式很经典的一个应用。</p><p>6.<strong>适配器模式</strong>: Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</p><p>7.<strong>策略模式</strong>: Spring 中有一个 Resource 接口，它的不同实现类，会根据不同的策略去访问资源。</p><h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><h3 id="什么是-IOC-和-DI"><a href="#什么是-IOC-和-DI" class="headerlink" title="什么是 IOC 和 DI?"></a>什么是 IOC 和 DI?</h3><p>**IOC(Inversion of Control:控制反转)**是一种设计思想，而不是一个具体的技术实现。IOC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring IOC 容器来管理。</p><p>**DI(Dependency Injection:依赖注入)**是指将对象所依赖的其他对象通过构造函数、Setter 方法或其他方式注入到对象中，从而消除了对象之间的耦合关系。</p><blockquote><p>IOC 是一种思想，它强调将对象之间的依赖关系的控制权交给容器来管理；DI 则是一种具体的实现方式，它强调将对象所依赖的其他对象通过注入的方式来消除对象之间的耦合关系。</p></blockquote><blockquote><p><strong>为什么要使用 IOC?</strong></p><p>最核心的是两个字<strong>解耦</strong>，硬编码会造成对象间的过度耦合，使用 IOC 之后，我们可以不用关心对象间的依赖。</p></blockquote><h3 id="有哪些依赖注入的实现方式"><a href="#有哪些依赖注入的实现方式" class="headerlink" title="有哪些依赖注入的实现方式?"></a>有哪些依赖注入的实现方式?</h3><ul><li><strong>构造器注入：</strong>是指通过构造方法将依赖项注入到对象中。在构造方法中，将依赖项作为参数传入，然后在对象被创建时将其保存在成员变量中。</li><li><strong>setter注入：</strong>是指通过setter方法将依赖项注入到对象中。在setter方法中，将依赖项作为参数传入，然后将其保存在成员变量中。</li><li><strong>接口注入：</strong>是指通过实现接口将依赖项注入到对象中。在接口中定义依赖项的setter方法，然后在实现类中实现该方法，将依赖项注入到对象中。</li><li><strong>注解注入：</strong>是指通过注解将依赖项注入到对象中。在依赖项上添加注解，然后在对象中使用@Autowired、@Resource注解将依赖项注入到对象中。</li></ul><h3 id="什么是-Spring-Bean"><a href="#什么是-Spring-Bean" class="headerlink" title="什么是 Spring Bean?"></a>什么是 Spring Bean?</h3><p>Bean 是那些被 Spring IOC 容器管理的对象。简单来说，Bean 就是通过 Spring 容器创建、装配和管理的对象实例。它可以是任何一个普通的 Java 对象，例如 POJO（普通的 Java 对象）、Service、DAO、Entity 等等。</p><h3 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h3><p><strong>singleton</strong>: IOC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</p><p><strong>prototype</strong>: 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</p><p><strong>request</strong>（仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</p><p><strong>session</strong>（仅 Web 应用可用）: 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</p><p><strong>application&#x2F;global-session</strong>（仅 Web 应用可用）: 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</p><p><strong>websocket</strong>（仅 Web 应用可用）: 每一次 WebSocket 会话产生一个新的 bean。</p><blockquote><p><strong>如何配置 bean 的作用域?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// xml方式</span><br>&lt;bean id=<span class="hljs-string">&quot;...&quot;</span> class=<span class="hljs-string">&quot;...&quot;</span> scope=<span class="hljs-string">&quot;singleton&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注解方式</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">personPrototype</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="了解-Spring-Bean-的生命周期吗"><a href="#了解-Spring-Bean-的生命周期吗" class="headerlink" title="了解 Spring Bean 的生命周期吗?"></a>了解 Spring Bean 的生命周期吗?</h3><p>Spring IOC 中 Bean 的生命周期大致分为五个阶段：<strong>实例化</strong>（Instantiation）、<strong>属性赋值</strong>（Populate）、<strong>初始化</strong>（Initialization 、<strong>使用</strong>、<strong>销毁</strong>（Destruction）。</p><blockquote><p>在 Spring 中，基本容器 BeanFactory 和扩展容器 ApplicationContext 的实例化时机不太一样，BeanFactory 采用的是延迟初始化的方式，也就是只有在第一次 getBean()的时候，才会实例化 Bean；ApplicationContext 启动之后会实例化所有的 Bean 定义。</p></blockquote><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202310231532049.png"></p><ul><li><p><strong>实例化：</strong>实例化一个 Bean 对象，为 Bean 分配内存空间</p></li><li><p><strong>属性赋值：</strong>为 Bean 设置相关属性和依赖</p></li><li><p><strong>初始化：</strong></p><ul><li>执行各种通知</li><li>执行初始化的前置方法</li><li>执行初始化方法</li><li>执行初始化的后置方法</li></ul></li><li><p><strong>使用：</strong>在程序中使用 Bean 对象</p></li><li><p><strong>销毁：</strong>将 Bean 对象进行销毁</p></li></ul><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202310231539982.jpg"></p><h3 id="Spring-中的-Bean-是线程安全的吗"><a href="#Spring-中的-Bean-是线程安全的吗" class="headerlink" title="Spring 中的 Bean 是线程安全的吗?"></a>Spring 中的 Bean 是线程安全的吗?</h3><p><strong>Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。</strong></p><p>prototype 作用域下，每次获取都会创建一个新的 Bean 实例，不存在资源竞争问题，所以不存在线程安全问题。</p><p>singleton 作用域下，IOC 容器中只有唯一的 Bean 实例，所有线程共享，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果单例 Bean 是无状态的（没有定义可变的成员变量），那么这个单例 Bean 是线程安全的。比如 Spring MVC 中的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。如果这个 Bean 是有状态的（包含可变的成员变量），那么可能就存在线程安全的问题。</p><blockquote><p><strong>单例 Bean 线程安全问题怎么解决?</strong></p><p>1.将 Bean 定义为多例</p><p>2.在 Bean 对象中尽量避免定义可变的成员变量</p><p>3.在类中定义一个 <code>ThreadLocal</code>(能保证多线程下变量的隔离) 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中(<strong>推荐</strong>)</p></blockquote><h3 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些?"></a>将一个类声明为 Bean 的注解有哪些?</h3><p><code>@Component</code>: 通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用 <code>@Component</code> 注解标注。</p><p><code>@Repository</code>: 对应持久层即 Dao 层，主要用于数据库相关操作。</p><p><code>@Service</code>: 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p><p><code>@Controller</code>: 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</p><p><code>@Configuration</code>: 声明该类为一个配置类，可以在此类中声明一个或多个 <code>@Bean</code> 方法。</p><h3 id="Component-和-Bean-的区别是什么"><a href="#Component-和-Bean-的区别是什么" class="headerlink" title="@Component 和 @Bean 的区别是什么?"></a>@Component 和 @Bean 的区别是什么?</h3><p><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p><p><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p><p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，没有办法在它的类上添加 <code>@Component</code> 注解的，这时候使用配置类 <code>@Configuration</code> 和 <code>@Bean</code> 搭配的方式，实现自动装配。</p><h3 id="注入-Bean-的注解有哪些"><a href="#注入-Bean-的注解有哪些" class="headerlink" title="注入 Bean 的注解有哪些?"></a>注入 Bean 的注解有哪些?</h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean，其中 <code>@Autowired</code> 和 <code>@Resource</code> 使用的较多一些。</p><blockquote><p><strong>@Autowired 和 @Resource 的区别是什么?</strong></p><ul><li><p><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</p></li><li><p><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和 <code>@Resource</code> 都需要通过名称才能正确匹配到对应的 Bean。<code>@Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</p></li><li><p><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</p></li></ul></blockquote><blockquote><p><strong>@Resource 的装配顺序：</strong></p><p>1.如果同时指定 name 和 type，则从容器中查找唯一匹配的 bean 装配，找不到则抛出异常。</p><p>2.如果指定 name 属性，则从容器中查找名称匹配的 bean 装配，找不到则抛出异常。</p><p>3.如果指定 type 属性，则从容器中查找类型唯一匹配的 bean 装配，找不到或者找到多个抛出异常。</p><p>4.如果不指定，则自动按照 byName 方式装配，如果没有匹配，则回退一个原始类型进行匹配，如果匹配则自动装配。</p></blockquote><h3 id="Spring-有哪些自动装配-bean-的方式"><a href="#Spring-有哪些自动装配-bean-的方式" class="headerlink" title="Spring 有哪些自动装配 bean 的方式?"></a>Spring 有哪些自动装配 bean 的方式?</h3><ul><li><strong>no</strong>: 默认方式，手动装配方式，需要通过 ref 设定 bean 的依赖关系。</li><li><strong>byName</strong>: 根据名称进行装配，当一个 bean 的名称和其他 bean 的属性一致，则自动装配。假设 Boss 类有一个名为 car 的属性，如果容器中刚好有一个名为 car 的 bean，Spring 就会自动将其装配给 Boss 类的 car 属性。</li><li><strong>byType</strong>: 根据bean的类型进行装配，当一个 bean 的属性类型与其他 bean 的属性的数据类型一致，则自动装配。假设 Boss 类有一个 Car 类型的属性，如果容器中刚好有一个 Car 类型的 Bean，Spring 就会自动将其装配给 Boss 类这个属性。</li><li><strong>constructor</strong>: 根据构造器进行装配，与 byType 类似，如果 bean 的构造器有与其他 bean 类型相同的属性，则进行自动装配。如果 Boss 类有一个构造函数，构造函数包含一个 Car 类型的参数，如果容器中有一个 Car 类型的 bean，则 Spring 将自动把这个 bean 作为 Boss 类构造函数的参数；如果容器中没有找到和构造函数入参匹配类型的 bean，则 Spring 将抛出异常。</li><li><strong>autodetect</strong>: 据 bean 的自省机制决定采用 byType 还是 constructor 进行自动装配，如果 bean 提供了默认的构造函数，则采用 byType，否则采用 constructor。</li></ul><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP?"></a>什么是AOP?</h3><p><strong>AOP(Aspect Oriented Programming)</strong>: 面向切面编程，通过预编译方式和运行期动态代理实现，在不修改源代码的情况下，给程序动态统一添加功能的一种技术。AOP 是 OOP 思想的延续。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>简单来说，AOP 就是在某一个类或方法执行前后打个标记，声明在执行到这里之前要先执行什么，执行完这里之后要接着执行什么。比如说，你去ATM取钱，取钱是一个功能，取完钱后向你的手机发送一条取钱信息，这就是新加的功能。</p><p>AOP 是基于<strong>动态代理</strong>实现的，如果是实现了接口的话就会使用 JDK 动态代理，否则使用 CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。</p><p>AOP 中的一些专业术语：</p><table><thead><tr><th align="center">术语</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">目标(Target)</td><td align="center">被通知的对象</td></tr><tr><td align="center">代理(Proxy)</td><td align="center">向目标对象应用通知之后创建的代理对象</td></tr><tr><td align="center">连接点(JoinPoint)</td><td align="center">目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr><td align="center">切入点(Pointcut)</td><td align="center">被切面拦截&#x2F;增强的连接点(切入点一定是连接点，连接点不一定是切入点)</td></tr><tr><td align="center">通知(Advice)</td><td align="center">增强的逻辑&#x2F;代码，即拦截到目标对象的连接点之后要做的事情</td></tr><tr><td align="center">切面(Aspect)</td><td align="center">切入点(Pointcut)+通知(Advice)</td></tr><tr><td align="center">Weaving(织入)</td><td align="center">将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table><h3 id="AOP-有哪些通知类型"><a href="#AOP-有哪些通知类型" class="headerlink" title="AOP 有哪些通知类型?"></a>AOP 有哪些通知类型?</h3><p><strong>Before</strong>(前置通知): 目标对象的方法调用之前触发。</p><p><strong>After</strong>(后置通知): 目标对象的方法调用之后触发。</p><p><strong>AfterReturning</strong>(返回通知): 目标对象的方法调用完成，在返回结果值之后触发。</p><p><strong>AfterThrowing</strong>(异常通知):目标对象的方法运行中抛出&#x2F;触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</p><p><strong>Around</strong>(环绕通知，优先级最高): 编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后执行操作，甚至不调用目标对象的方法。</p><h3 id="多个切面的执行顺序如何控制"><a href="#多个切面的执行顺序如何控制" class="headerlink" title="多个切面的执行顺序如何控制?"></a>多个切面的执行顺序如何控制?</h3><p>1.使用 <code>@Order</code> 注解定义切面顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 值越小优先级越高</span><br><span class="hljs-meta">@Order(1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br></code></pre></td></tr></table></figure><p>2.实现 <code>Ordered</code> 接口并重写 <code>getOrder</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回值越小优先级越高</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别?"></a>Spring AOP 和 AspectJ AOP 有什么区别?</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="Spring-MVC-的核心组件有哪些"><a href="#Spring-MVC-的核心组件有哪些" class="headerlink" title="Spring MVC 的核心组件有哪些?"></a>Spring MVC 的核心组件有哪些?</h3><p><strong><code>DispatcherServlet</code></strong>: **前端控制器(中央控制器)**，是整个流程控制的核心，负责接收请求、分发，并给予客户端响应。</p><p><strong><code>HandlerMapping</code></strong>: <strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p><p><strong><code>HandlerAdapter</code></strong>: <strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>。</p><p><strong><code>Handler</code></strong>: <strong>请求处理器</strong>，处理实际请求的处理器。</p><p><strong><code>ViewResolver</code></strong>: <strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图&#x2F;视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端。</p><h3 id="Spring-MVC-的工作流程"><a href="#Spring-MVC-的工作流程" class="headerlink" title="Spring MVC 的工作流程?"></a>Spring MVC 的工作流程?</h3><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images202310241535775.jpg"></p><p>1.客户端（浏览器）发送请求， <code>DispatcherServlet</code> 拦截请求。</p><p>2.<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> ，<code>HandlerMapping</code> 根据URL去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p><p>3.<code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code> 执行 <code>Handler</code>。</p><p>4.<code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给 <code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p><p>5.<code>DispatcherServlet</code> 将 <code>ModelAndView</code> 交给 <code>ViewReslover</code> 视图解析器解析，然后返回真正的视图。</p><p>6.<code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p><p>7.<code>DispatcherServlet</code> 将结果响应给客户端。</p><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="Spring-管理事务的方式有哪些"><a href="#Spring-管理事务的方式有哪些" class="headerlink" title="Spring 管理事务的方式有哪些?"></a>Spring 管理事务的方式有哪些?</h3><p><strong>编程式事务</strong>：在代码中硬编码(不推荐使用): 通过 <code>TransactionTemplate</code> 或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用。</p><p><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解(推荐使用): 实际是通过 AOP 实现(基于<code>@Transactional</code> 的全注解方式使用最多)。</p><h3 id="Spring-事务中有哪几种事务传播行为"><a href="#Spring-事务中有哪几种事务传播行为" class="headerlink" title="Spring 事务中有哪几种事务传播行为?"></a>Spring 事务中有哪几种事务传播行为?</h3><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p><table><thead><tr><th align="center">事务传播行为</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">REQUIRED(默认)</td><td align="center">如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</td></tr><tr><td align="center">REQUIRES_NEW</td><td align="center">创建一个新的事务，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td align="center">NESTED</td><td align="center">如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，等价于REQUIRED。</td></tr><tr><td align="center">MANDATORY</td><td align="center">如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</td></tr><tr><td align="center">SUPPORTS</td><td align="center">如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</td></tr><tr><td align="center">NOT_SUPPORTED</td><td align="center">以非事务方式运行，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td align="center">NEVER</td><td align="center">以非事务方式运行，如果当前存在事务，则抛出异常。</td></tr></tbody></table><h3 id="Spring-事务中有哪几种隔离级别"><a href="#Spring-事务中有哪几种隔离级别" class="headerlink" title="Spring 事务中有哪几种隔离级别?"></a>Spring 事务中有哪几种隔离级别?</h3><table><thead><tr><th align="center">事务隔离级别</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ISOLATION_DEFAULT</td><td align="center">使用后端数据库默认的隔离级别，MySQL 默认采用 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用 <code>READ_COMMITTED</code> 隔离级别。</td></tr><tr><td align="center">ISOLATION_READ_UNCOMMITTED</td><td align="center">读未提交，允许读取尚未提交的数据变更，<strong>可能会导致脏读、不可重复读或幻读</strong>。</td></tr><tr><td align="center">ISOLATION_READ_COMMITTED</td><td align="center">读已提交，允许读取并发事务已经提交的数据，<strong>可能会导致不可重复读或幻读</strong>。</td></tr><tr><td align="center">ISOLATION_REPEATABLE_READ</td><td align="center">可重复读，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可能会导致幻读</strong>。</td></tr><tr><td align="center">ISOLATION_SERIALIZABLE</td><td align="center">串行化，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，但是这将严重影响程序的性能。</td></tr></tbody></table><h3 id="了解-Transactional-rollbackFor-Exception-class-注解吗"><a href="#了解-Transactional-rollbackFor-Exception-class-注解吗" class="headerlink" title="了解 @Transactional(rollbackFor &#x3D; Exception.class) 注解吗?"></a>了解 @Transactional(rollbackFor &#x3D; Exception.class) 注解吗?</h3><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。在 <code>@Transactional</code> 注解中如果不配置 <code>rollbackFor</code> 属性,那么事务只会在遇到 <code>RuntimeException</code> 的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>，可以让事务在遇到非运行时异常时也回滚。</p><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="Spring-Boot-有哪些优势"><a href="#Spring-Boot-有哪些优势" class="headerlink" title="Spring Boot 有哪些优势?"></a>Spring Boot 有哪些优势?</h3><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p>Spring Boot 以<code>约定大于配置</code>核心思想展开，相比 Spring 具有如下优势：</p><p>1.Spring Boot 可以快速创建独立的 Spring 应用程序。</p><p>2.Spring Boot 内嵌了如 Tomcat，Jetty 和 Undertow 这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</p><p>3.Spring Boot 无需再像 Spring 一样使用一堆繁琐的 xml 文件配置。</p><p>4.Spring Boot 可以自动配置(核心)Spring。SpringBoot 将原有的 XML 配置改为 Java 配置，将 bean 注入改为使用注解注入的方式(<code>@Autowire</code>)，并将多个 xml、properties 配置浓缩在一个 appliaction.yml 配置文件中。</p><p>5.Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。</p><p>6。Spring Boot 可以快速整合常用依赖（开发库，例如 spring-webmvc、jackson-json、validation-api 和 tomcat 等），提供的 POM 可以简化 Maven 的配置。当我们引入核心依赖时，SpringBoot 会自引入其他依赖。</p><h3 id="了解-Spring-Boot-自动配置原理吗"><a href="#了解-Spring-Boot-自动配置原理吗" class="headerlink" title="了解 Spring Boot 自动配置原理吗?"></a>了解 Spring Boot 自动配置原理吗?</h3><p>1.在 SpringBoot 项目的启动引导类上都有一个注解 <code>@SpringBootApplication</code>，这个注解是一个复合注解，其中有三个注解构成，分别是：</p><ul><li>@SpringBootConfiguration: 是 @Configuration 的派生注解，标注当前类是一个 SpringBoot 的配置类</li><li>@ComponentScan: 开启组件扫描，默认扫描的是当前启动引导了所在包以及子包</li><li><strong>@EnableAutoConfiguration: 开启自动配置(自动配置核心注解)</strong></li></ul><p>2.在 <code>@EnableAutoConfiguration</code> 注解的内容使用 @Import 注解导入了一个 <code>AutoConfigurationImportSelector.class</code> 的类，在 <code>AutoConfigurationImportSelector.class</code> 中的 <code>selectImports</code> 方法内通过一系列的方法调用，最终需要加载类加载路径下 <code>META-INF</code> 下面的 <code>spring.factories</code> 配置文件</p><p>3.在 <code>META-INF/spring.factories</code> 配置文件中, 定义了很多的自动配置类的完全限定路径，这些配置类都会被加载</p><p>4.加载配置类之后, 会根据配置类或者配置方法上的 <code>@ConditionalOnXxxx</code> 条件化注解判断是否满足条件，如果满足条件就会从属性配置类中读取相关配置，执行配置类中的配置方法，完成自动配置</p><h3 id="了解-Spring-Boot-的启动流程"><a href="#了解-Spring-Boot-的启动流程" class="headerlink" title="了解 Spring Boot 的启动流程?"></a>了解 Spring Boot 的启动流程?</h3><p>SpringBoot 项目在启动的时候, 首先会执行启动引导类里面的 <code>SpringApplication.run(AdminApplication.class, args)</code> 方法，这个run方法主要做的事情可以分为三个部分： </p><p>第一部分进行 <code>SpringApplication</code> 的初始化模块，配置一些基本的环境变量、资源、构造器、监听器</p><p>第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块</p><p>第三部分是自动化配置</p><h3 id="Spring-Boot-怎么解决跨域问题"><a href="#Spring-Boot-怎么解决跨域问题" class="headerlink" title="Spring Boot 怎么解决跨域问题?"></a>Spring Boot 怎么解决跨域问题?</h3><p><strong>跨域问题本质是浏览器的一种保护机制，它的初衷是为了保证用户的安全，防止恶意网站窃取数据。</strong></p><p><strong>域：协议 + 域名 + 端口</strong>，三者完全相同则为同域，反之有其一不同均为跨域。</p><p>1.<strong>通过注解解决跨域</strong></p><p>使用 <code>@CrossOrigin</code> 注解可以实现跨域，此注解既可以修饰类，也可以修饰方法。当修饰类时，表示此类中的所有接口都可以跨域；当修饰方法时，表示此方法可以跨域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@CrossOrigin(origins = &quot;*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> HashMap&lt;String, Object&gt; <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-number">200</span>);<br>            put(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);<br>            put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：实现比较简单；缺点：此方式只能实现局部跨域，当一个项目中存在多个类的话就会比较麻烦（需要给所有类上都添加此注解）。</p><p>2.<strong>全局配置解决跨域</strong></p><p>定义配置类，添加 <code>@Configuration</code> 注解，实现 WebMvcConfigurer 接口，再重写 addCorsMappings 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 所有接口</span><br>                .allowCredentials(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 是否发送 Cookie</span><br>                .allowedOriginPatterns(<span class="hljs-string">&quot;*&quot;</span>) <span class="hljs-comment">// 支持域</span><br>                .allowedMethods(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>&#125;) <span class="hljs-comment">// 支持方法</span><br>                .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)<br>                .exposedHeaders(<span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO流</title>
    <link href="/posts/59ae8782.html"/>
    <url>/posts/59ae8782.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 19, 2023</p><h2 id="IO-流概述"><a href="#IO-流概述" class="headerlink" title="IO 流概述"></a>IO 流概述</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p><p><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p><p>IO 流体系结构图：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310211439867.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO流</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/posts/3e225941.html"/>
    <url>/posts/3e225941.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 13, 2023</p><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><h3 id="什么是进程和线程"><a href="#什么是进程和线程" class="headerlink" title="什么是进程和线程?"></a>什么是进程和线程?</h3><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位。</p><p><strong>线程</strong>是进程的一个执行路径，一个进程中至少包含一个线程，进程中的多个线程共享进程的堆和方法区资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><blockquote><p><strong>引入线程前，进程是资源分配和独立调度的基本单位。引入线程后，进程是资源分配的基本单位，线程是独立调度的基本单位。</strong></p></blockquote><blockquote><p><strong>程序计数器为什么是私有的?</strong></p><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p></blockquote><blockquote><p><strong>虚拟机栈和本地方法栈为什么是私有的?</strong></p><p>虚拟机栈和本地方法栈私有是为了<strong>保证线程中的局部变量不被别的线程访问到</strong>。</p></blockquote><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别?"></a>进程和线程的区别?</h3><ul><li>进程是资源（包括内存、打开的文件等）分配的基本单位，线程是 CPU 调度的基本单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源；</li><li>线程能减少并发执行的时间和空间开销，但不利于资源的管理和保护，而进程正相反。</li></ul><h3 id="什么是并发与并行"><a href="#什么是并发与并行" class="headerlink" title="什么是并发与并行?"></a>什么是并发与并行?</h3><p><strong>并发：</strong>宏观上在<strong>一段时间</strong>内能同时运行多个程序。当然，这些程序宏观上是同时发生的，但微观上是交替发生的。操作系统通过引入进程和线程，使得程序能够并发运行。</p><p><strong>并行：</strong>并行指<strong>同一时刻</strong>能运行多个指令，指两个或多个事件在同一时刻同时发生。</p><h3 id="什么是同步和异步"><a href="#什么是同步和异步" class="headerlink" title="什么是同步和异步?"></a>什么是同步和异步?</h3><p><strong>同步：</strong>发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</p><p><strong>异步：</strong>调用在发出之后，不用等待返回结果，该调用直接返回。</p><h3 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h3><table><thead><tr><th align="center">状态</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NEW</td><td align="center">初始状态：线程被创建，但还没有调用start()方法</td></tr><tr><td align="center">RUNNABLE</td><td align="center">当调用了 start 方法后，线程就进入了运行状态（RUNNABLE ），Java 线程将操作系统中线程的就绪（READY）和运行（RUNNING）两种状态统称为 “RUNNABLE”。</td></tr><tr><td align="center">BLOCKED</td><td align="center">阻塞状态：表示线程阻塞于锁</td></tr><tr><td align="center">WAITING</td><td align="center">等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td align="center">TIME_WAITING</td><td align="center">超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</td></tr><tr><td align="center">TERMINATED</td><td align="center">终止状态，表示该线程已经运行完毕。</td></tr></tbody></table><p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310132019366.jpg"></p><h3 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换?"></a>什么是线程上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><blockquote><p>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</p><p>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</p><p>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</p><p>被终止或结束运行</p></blockquote><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><h3 id="了解守护线程吗"><a href="#了解守护线程吗" class="headerlink" title="了解守护线程吗?"></a>了解守护线程吗?</h3><p><strong>Java 中的线程分为两类，分别为 daemon 线程(守护线程)和 user 线程(用户线程)。</strong>在 JVM 启动时会调用 main 函数，main函数所在的线程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程，比如 GC 线程(垃圾回收线程)。</p><p>守护线程的使用有以下要点：</p><ul><li>当程序中所有的用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出(也就是说只要存在一个用户线程在运行，守护线程就不会结束)。</li><li>守护线程必须在 <code>start</code> 启动前通过 <code>setDaemon()</code> 方法将状态设置为 true，启动后不能进行设置，否则报 <code>InterruptedException</code> 异常。</li><li>守护线程存在被 JVM 强制终止的风险，所以在守护线程中尽量不去访问系统资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失，<strong>所以守护线程适合执行无需完整执行的后台任务</strong>。</li><li>守护线程中创建的线程也是守护线程。</li></ul><blockquote><p><strong>Java 默认有几个线程?</strong></p><p>两个，<strong>main</strong>线程和<strong>GC</strong>线程。</p></blockquote><h3 id="说说线程的几种创建方式"><a href="#说说线程的几种创建方式" class="headerlink" title="说说线程的几种创建方式?"></a>说说线程的几种创建方式?</h3><p>Java 中创建线程主要有三种方式，分别为继承 <code>Thread</code> 类、实现 <code>Runnable</code> 接口、实现 <code>Callable</code> 接口。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310142230148.jpg"></p><p>1.继承 <code>Thread</code> 类并重写 <code>run()</code> 方法，创建一个线程对象，调用 <code>start()</code> 方法启动线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure><p>2.实现 <code>Runnable</code> 接口并实现 <code>run()</code> 方法，创建一个 <code>Runnable</code> 对象，将该对象作为参数传入 <code>Thread</code> 的构造方法中，创建一个线程对象，调用 <code>start()</code> 方法启动线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br></code></pre></td></tr></table></figure><p>3.实现 <code>Callable</code> 接口并实现 <code>call()</code> 方法，创建一个 <code>Callable</code> 对象，将该对象作为参数传入 <code>FutureTask</code> 的构造方法中，创建一个 <code>FutureTask</code> 对象，将 <code>FutureTask</code> 对象作为参数传入 <code>Thread</code> 的构造方法中，创建一个线程对象，调用 <code>start()</code> 方法启动线程。可以使用 <code>FutureTask</code>对象中的 <code>get()</code> 方法获取 <code>call()</code> 方法的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程要执行的代码</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>thread.start();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br></code></pre></td></tr></table></figure><h3 id="说说-Runnable-接口和-Callable-接口的区别"><a href="#说说-Runnable-接口和-Callable-接口的区别" class="headerlink" title="说说 Runnable 接口和 Callable 接口的区别?"></a>说说 Runnable 接口和 Callable 接口的区别?</h3><p>1.<code>Runnable</code> 接口 <code>run()</code> 方法没有返回值；<code>Callable</code> 接口 <code>call()</code> 方法有返回值，是个泛型，和 <code>Future</code>、 <code>FutureTask</code> 配合可以用来获取异步执行的结果 (需要调用 <code>FutureTask.get()</code> 方法得到， 此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞)。</p><p>2.<code>Runnable</code> 接口 <code>run()</code> 方法只能抛出运行时异常，且无法捕获处理；<code>Callable</code> 接口 <code>call()</code> 方法允许抛出异常，可以获取异常信息。</p><h3 id="调用-start-方法时会执行-run-方法，那为什么不直接调用-run-方法"><a href="#调用-start-方法时会执行-run-方法，那为什么不直接调用-run-方法" class="headerlink" title="调用 start() 方法时会执行 run() 方法，那为什么不直接调用 run() 方法?"></a>调用 start() 方法时会执行 run() 方法，那为什么不直接调用 run() 方法?</h3><p><code>run()</code> 方法被称为<strong>线程执行体</strong>，它的方法体代表了线程需要完成的任务，而 <code>start()</code> 方法是用来启动线程的。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。</p><p>如果直接调用线程对象的 <code>run()</code> 方法，则 <code>run()</code> 方法立即就会被执行，而且在 <code>run()</code> 方法返回之前其他线程无法并发执行。<strong>也就是说，如果直接调用线程对象的 <code>run()</code> 方法，系统把线程对象当成一个普通对象，而 <code>run()</code> 方法也是一个普通方法，而不是线程执行体</strong>。</p><h3 id="知道-sleep-方法和-wait-方法的区别吗"><a href="#知道-sleep-方法和-wait-方法的区别吗" class="headerlink" title="知道 sleep() 方法和 wait() 方法的区别吗?"></a>知道 sleep() 方法和 wait() 方法的区别吗?</h3><ul><li><code>sleep()</code> 方法是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 方法则是 <code>Object</code> 类的本地方法。</li><li><strong><code>sleep()</code> 方法不会释放锁，而 <code>wait()</code> 方法会释放锁</strong> 。</li><li><code>sleep()</code>方法一般用于暂停线程执行，而 <code>wait()</code> 方法用于线程之间的通信。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>wait()</code> 方法只能在 被 <code>synchronized</code> 修饰的方法或者代码块里面使用，而 <code>sleep()</code> 方法可以在任何地方使用。</li></ul><blockquote><p><strong>Thread.sleep(0) 有什么用?</strong></p><p>sleep(timeout) 的意思是，线程丢掉 CPU 时间片，挂起 timeout 秒，进入等待态（等待队列中的线程是不参与 CPU 调度的），timeout 秒之后，再转入就绪态，开始等候 CPU 调度。</p><p><strong>当一个线程调用 <code>Thread.sleep(0)</code> 方法时，它会立即放弃自己的 CPU 时间片，然后直接进入就绪态，继续参与 CPU 调度，使得其他等待线程有机会先执行，如果没有其他等待线程，则当前线程会继续执行。这种方式可以防止当前线程长时间占用 CPU 而导致其他线程无法执行的问题，从而提高系统的并发性能</strong>。</p></blockquote><h2 id="Java-内存模型-JMM"><a href="#Java-内存模型-JMM" class="headerlink" title="Java 内存模型(JMM)"></a>Java 内存模型(JMM)</h2><h3 id="知道原子性、可见性、有序性吗"><a href="#知道原子性、可见性、有序性吗" class="headerlink" title="知道原子性、可见性、有序性吗?"></a>知道原子性、可见性、有序性吗?</h3><ul><li><strong>原子性：</strong>指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行( JMM 只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用 <code>synchronized</code> 关键字)。</li><li><strong>可见性：</strong>指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改( Java 使用 <code>volatile</code> 关键字来保证可见性的，除此之外，使用<code>final</code> 和 <code>synchronized</code> 关键字也能保证可见性)。</li><li><strong>有序性：</strong>指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排(<code>synchronized</code> 或者 <code>volatile</code> 关键字都可以保证多线程之间操作的有序性)。</li></ul><blockquote><p><strong>如何保证变量的可见性?</strong></p><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p></blockquote><h3 id="什么是指令重排"><a href="#什么是指令重排" class="headerlink" title="什么是指令重排?"></a>什么是指令重排?</h3><p>指令的重排序：Java 语言规范规定了JVM线程内部维持顺序化语义，也就是说<strong>只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致</strong>。</p><p>指令重排序的意义在于：JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。</p><blockquote><p>重排序的分类：</p><p>1.编译期重排：编译源代码时，编译器依据对上下文的分析，对指令进行重排序，以之更适合于CPU的并行执行。</p><p>2.运行期重排：CPU在执行过程中，动态分析依赖部件的效能，对指令做重排序优化。</p><p>3.内存重排：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></blockquote><h3 id="如何禁止指令重排序"><a href="#如何禁止指令重排序" class="headerlink" title="如何禁止指令重排序?"></a>如何禁止指令重排序?</h3><p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><p>我们比较熟悉的双重校验锁实现单例模式就是一个经典的指令重排的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 双重校验锁实现对象单例（线程安全）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的，<code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><p>1.为 <code>uniqueInstance</code> 分配内存空间</p><p>2.初始化 <code>uniqueInstance</code></p><p>3.将 <code>uniqueInstance</code> 指向分配的内存地址</p><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized-是什么？有什么用"><a href="#synchronized-是什么？有什么用" class="headerlink" title="synchronized 是什么？有什么用?"></a>synchronized 是什么？有什么用?</h3><p><code>synchronized</code> 是 Java 中的一个关键字，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>在 Java 早期版本中，<code>synchronized</code> 属于<strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>在 Java 6 之后，<code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此，<code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 关键字。</p><h3 id="怎么使用-synchronized-关键字"><a href="#怎么使用-synchronized-关键字" class="headerlink" title="怎么使用 synchronized 关键字?"></a>怎么使用 synchronized 关键字?</h3><p><code>synchronized</code> 关键字的使用方式主要有 3 种: 修饰实例方法、修饰静态方法、修饰代码块。</p><p>1.修饰实例方法（锁当前实例对象）: </p><p>给当前对象实例加锁，进入同步代码前要获得<strong>当前对象实例的锁</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.修饰静态方法（锁当前类）: </p><p>给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得<strong>当前 class 的锁</strong>。这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？</p><p>不互斥，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p></blockquote><p>3.修饰代码块（锁指定对象&#x2F;类）: </p><ul><li><code>synchronized(object)</code> 表示进入同步代码前要获得<strong>给定对象的锁</strong>。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得<strong>给定 Class 的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">// 业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</li></ul></blockquote><blockquote><p>构造方法可以用 synchronized 关键字修饰吗?</p><p>构造方法本身就是属于线程安全的，所以<strong>不能使用 synchronized 关键字修饰</strong>。</p></blockquote><h3 id="JDK-1-6-之后-synchronized-底层做了哪些优化"><a href="#JDK-1-6-之后-synchronized-底层做了哪些优化" class="headerlink" title="JDK 1.6 之后 synchronized 底层做了哪些优化?"></a>JDK 1.6 之后 synchronized 底层做了哪些优化?</h3><p>JDK 1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><ul><li>偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS 操作都不做。</li><li>轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有 CAS 操作的开销。</li><li>自旋锁：减少不必要的 CPU 上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</li><li>锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li>锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</li></ul><blockquote><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p>锁升级方向：无锁—&gt;偏向锁—&gt; 轻量级锁—&gt;重量级锁</p></blockquote><h3 id="说说-synchronized-和-volatile-的区别"><a href="#说说-synchronized-和-volatile-的区别" class="headerlink" title="说说 synchronized 和 volatile 的区别?"></a>说说 synchronized 和 volatile 的区别?</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在。</p><p>1.<code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</p><p>2.<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p><p>3.<code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</p><h3 id="说说-synchronized-和-Lock-的区别"><a href="#说说-synchronized-和-Lock-的区别" class="headerlink" title="说说 synchronized 和 Lock 的区别?"></a>说说 synchronized 和 Lock 的区别?</h3><p>1.<code>synchronized</code> 是 Java 内置关键字；而<code>Lock</code> 是 java.util.concurrent.locks 包下的一个接口。</p><p>2.<code>synchronized</code> 可以给类、方法、代码块加锁；而 <code>Lock</code> 只能给代码块加锁。</p><p>3.<code>synchronized</code> 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 <code>Lock</code> 需要手动加锁和释放锁，如果使用不当没有使用 <code>unlock()</code> 方法去释放锁就会造成死锁(<strong>所以最好将同步代码块用 <code>try catch</code> 包起来，<code>finally</code> 中写入 <code>unlock()</code>方法，避免死锁的发生</strong>)。</p><p>4.<code>Lock</code> 可以通过 <code>tryLock()</code> 方法判断是否获取到了锁，而 <code>synchronized</code> 不能。</p><p>5.<code>synchronized</code> 是可重入锁、不可中断、非公平锁。<code>Lock</code> 是可重入锁、可中断、可公平。</p><h3 id="ReentrantLock-是什么"><a href="#ReentrantLock-是什么" class="headerlink" title="ReentrantLock 是什么?"></a>ReentrantLock 是什么?</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。<code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么是公平锁和非公平锁"><a href="#什么是公平锁和非公平锁" class="headerlink" title="什么是公平锁和非公平锁?"></a>什么是公平锁和非公平锁?</h3><p><strong>公平锁:</strong> 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p><p><strong>非公平锁:</strong> 锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p><h3 id="什么是可中断锁和不可中断锁"><a href="#什么是可中断锁和不可中断锁" class="headerlink" title="什么是可中断锁和不可中断锁?"></a>什么是可中断锁和不可中断锁?</h3><p><strong>可中断锁:</strong> 获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</p><p><strong>不可中断锁:</strong> 一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</p><h3 id="什么是共享锁和独占锁"><a href="#什么是共享锁和独占锁" class="headerlink" title="什么是共享锁和独占锁?"></a>什么是共享锁和独占锁?</h3><p><strong>共享锁:</strong> 一把锁可以被多个线程同时获得。</p><p><strong>独占锁:</strong> 一把锁只能被一个线程获得。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁?"></a>什么是死锁?</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><blockquote><p><strong>产生死锁的四个必要条件：</strong></p><p>1.互斥条件：该资源任意一个时刻只由一个线程占用。</p><p>2.请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>3.不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p>4.环路等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</p></blockquote><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁?"></a>如何避免死锁?</h4><p><strong>至少破坏死锁发生的一个条件：</strong></p><blockquote><p><strong>互斥条件没有办法破坏，因为用锁为的就是互斥。</strong></p><p><strong>破坏请求与保持条件：</strong>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件：</strong>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件：</strong>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></blockquote><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么?"></a>ThreadLocal 是什么?</h3><p><code>ThreadLocal</code>，也就是线程本地变量。如果创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个ThreadLocal变量，任何一个线程都能并发访问localVariable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程可以在任何地方使用localVariable，写入变量</span><br>localVariable.set(<span class="hljs-string">&quot;Java&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程在任何地方读取的都是它写入的变量</span><br>localVariable.get();<br></code></pre></td></tr></table></figure><h3 id="了解-ThreadLocal-内存泄漏吗"><a href="#了解-ThreadLocal-内存泄漏吗" class="headerlink" title="了解 ThreadLocal 内存泄漏吗?"></a>了解 ThreadLocal 内存泄漏吗?</h3><p><code>ThreadLocalMap</code> 中的 key 为 <code>ThreadLocal</code> 的弱引用，value 为强引用，如果 <code>ThreadLocal</code> 没有被外部强引用，垃圾回收时 key 会被清理掉，但value不会；这时 key &#x3D; null，而 value !&#x3D; null，如果不做处理，value 将永远不会被GC掉，就有可能发生内存泄漏。</p><p><code>ThreadLocalMap</code> 的实现中考虑了这个问题，在调用 get()&#x2F;set()&#x2F;remove() 方法时会清理掉 key &#x3D; null 的 entry，在编程时如果意识到当前编写的 run() 方法里不再会使用 <code>ThreadLocal</code> 了，最好手动调用 remove()方法。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池?"></a>什么是线程池?</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><blockquote><p><strong>线程池的优势:</strong></p><p><strong>1.降低资源消耗:</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p><strong>2.提高响应速度:</strong> 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p><strong>3.提高线程的可管理性:</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></blockquote><h3 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h3><p><strong>方式一：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建</strong></p><p><strong><code>FixedThreadPool</code>：</strong>该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p><p><strong><code>SingleThreadExecutor</code>：</strong>该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p><p><strong><code>CachedThreadPool</code>：</strong>该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</p><p><strong><code>ScheduledThreadPool</code>：</strong>该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</p><blockquote><p>《阿里巴巴 Java 开发手册》中不允许使用 <code>Executors</code> 创建线程池，这是因为两点，一是Executors提供的模板不够灵活，多数情况需要程序员自定义线程池，二是模板容易造成内存溢出（1和2队列过载、3线程池过载）。</p></blockquote><p><strong>方式二：通过 <code>ThreadPoolExecutor</code> 构造方法创建</strong></p><p><code>ThreadPoolExecutor</code> 一共有4个构造器，其中最核心的就是下面给出的，另外 3 个只是在其基础上为一些参数设定了默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"><strong>参数</strong></th><th align="center"><strong>类型</strong></th><th align="center"><strong>意义</strong></th></tr></thead><tbody><tr><td align="center">corePoolSize</td><td align="center">int</td><td align="center">核心线程池容量</td></tr><tr><td align="center">maximumPoolSize</td><td align="center">int</td><td align="center">线程池总容量</td></tr><tr><td align="center">keepAliveTime</td><td align="center">long</td><td align="center">核心外线程最大空闲时间，空闲超过这个时间就会被销毁</td></tr><tr><td align="center">unit</td><td align="center">TimeUnit</td><td align="center">keepAliveTime 的时间单位</td></tr><tr><td align="center">workQueue</td><td align="center">BlockingQueue</td><td align="center">任务队列</td></tr><tr><td align="center">threadFactory</td><td align="center">ThreadFactory</td><td align="center">产生线程的工厂</td></tr><tr><td align="center">handler</td><td align="center">RejectedExecutionHandler</td><td align="center">拒绝执行处理器，当线程池饱和时，按照该参数对应的饱和策略对新任务进行拒绝处理</td></tr></tbody></table><p><strong>线程池的饱和策略：</strong></p><p><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</p><p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</p><p><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</p><p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>本文仅用于个人学习，不涉及出售或倒卖</p><p>文中部分引用 JavaGuide 作者网站中的内容，<a href="https://javaguide.cn/">了解详情戳此处</a>。</p><p>文中部分引用 三分恶 作者网站中的内容，<a href="https://javabetter.cn/">了解详情戳此处</a>。</p><p>文中部分引用 CSView 作者网站中的内容，<a href="https://www.csview.cn/">了解详情戳此处</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合篇</title>
    <link href="/posts/55d6653c.html"/>
    <url>/posts/55d6653c.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 05, 2023</p><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h3 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><p>Java 集合框架如下图所示：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310051433999.png"></p><h3 id="知道-List-Set-Queue-Map-四者的区别吗"><a href="#知道-List-Set-Queue-Map-四者的区别吗" class="headerlink" title="知道 List, Set, Queue, Map 四者的区别吗?"></a>知道 List, Set, Queue, Map 四者的区别吗?</h3><p><code>List</code>：存储的元素是有序的、可重复的。</p><p><code>Set</code>：存储的元素不可重复的。</p><p><code>Queue</code>：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><p><code>Map</code>：使用键值对（key-value）存储；key 是无序的、不可重复的；value 是无序的、可重复的，每个键最多映射到一个值。</p><h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p><code>ArrayList</code>：<code>Object[]</code> 数组</p><p><code>Vector</code>：<code>Object[]</code> 数组</p><p><code>LinkedList</code>：双向链表(JDK 1.6 之前为循环链表，JDK 1.7 取消了循环)</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</p><p><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</p><p><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</p><p><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>HashMap</code>：</p><p>JDK 1.8 之前由数组+链表组成，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（”拉链法”解决冲突）。</p><blockquote><p>拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></blockquote><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310052110150.png"></p><p>JDK 1.8 以后由数组+链表&#x2F;红黑树组成，在解决哈希冲突时有了较大的变化，当链表长度大于 8 并且数组长度大于等于 64（如果当前数组的长度小于 64，那么会选择先进行数组扩容）时将链表转化为红黑树，以减少搜索时间。如果红黑树节点个数小于 6 ，退化为链表。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310052111698.png"></p><p><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑</p><p><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</p><p><code>TreeMap</code>：红黑树（自平衡的排序二叉树）</p><h2 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h2><h3 id="说说ArrayList-和-Array（数组）的区别"><a href="#说说ArrayList-和-Array（数组）的区别" class="headerlink" title="说说ArrayList 和 Array（数组）的区别?"></a>说说ArrayList 和 Array（数组）的区别?</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活。</p><p><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</p><p><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</p><p><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</p><p><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</p><p><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</p><h3 id="知道ArrayList-插入和删除元素的时间复杂度吗"><a href="#知道ArrayList-插入和删除元素的时间复杂度吗" class="headerlink" title="知道ArrayList 插入和删除元素的时间复杂度吗?"></a>知道ArrayList 插入和删除元素的时间复杂度吗?</h3><p><strong>插入</strong>：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 <code>O(n)</code>。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 <code>O(1)</code>，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 <code>O(n)</code> 的操作将原数组复制到新的更大的数组中，然后再执行 <code>O(1)</code> 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 <code>O(n)</code>。</li></ul><p><strong>删除</strong>：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 <code>O(n)</code>。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 <code>O(1)</code>。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 <code>O(n)</code>。</li></ul><blockquote><p><strong>LinkedList 插入和删除元素的时间复杂度?</strong></p><p>1.头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 <code>O(1)</code>。</p><p>2.尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 <code>O(1)</code>。</p><p>3.指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 <code>O(n)</code>。</p></blockquote><h3 id="知道-ArrayList-的扩容机制吗"><a href="#知道-ArrayList-的扩容机制吗" class="headerlink" title="知道 ArrayList 的扩容机制吗?"></a>知道 ArrayList 的扩容机制吗?</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，所以最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 1.8</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断数组是否越界</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-comment">// 扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 1.5倍</span><br>    <br>    <span class="hljs-comment">// 检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行)hugeCapacity()方法来比较 minCapacity 和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-comment">// 如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为Integer.MAX_VALUE - 8</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h2><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p><strong>相同点：</strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都是线程不安全的。</p><p><strong>不同点：</strong></p><p>（1）底层数据结构不同：<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p><p>（2）应用场景不同：<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p><h2 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h3><blockquote><p>initCapacity：初始容量（默认16）</p><p>loadFactor：负载因子（默认0.75）</p><p>threshold：阈值（initCapacity * loadFactor）</p></blockquote><p>JDK 1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><blockquote><p><strong>扰动函数：</strong>指的是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法，换句话说使用扰动函数之后可以减少碰撞。</p></blockquote><p>JDK 1.8 以后由数组+链表&#x2F;红黑树组成，在解决哈希冲突时有了较大的变化，当链表长度大于 8 并且数组长度大于等于 64（如果当前数组的长度小于 64，那么会选择先进行数组扩容）时，将链表转化为红黑树，以减少搜索时间。如果红黑树节点个数小于 6 ，退化为链表。</p><blockquote><p>TreeMap、TreeSet 以及 JDK 1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><h3 id="说说-HashMap-和-Hashtable-的区别"><a href="#说说-HashMap-和-Hashtable-的区别" class="headerlink" title="说说 HashMap 和 Hashtable 的区别?"></a>说说 HashMap 和 Hashtable 的区别?</h3><p><strong>1.底层数据结构：</strong> JDK 1.8 之前由数组+链表组成，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的；JDK 1.8 以后由数组+链表&#x2F;红黑树组成，在解决哈希冲突时有了较大的变化，当链表长度大于 8 并且数组长度大于等于 64（如果当前数组的长度小于 64，那么会选择先进行数组扩容）时，将链表转化为红黑树，以减少搜索时间。如果红黑树节点个数小于 6 ，退化为链表。而<code>Hashtable</code> 没有这样的机制。</p><p><strong>2.对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p><p><strong>3.初始容量大小和每次扩充容量大小的不同：</strong>（1）创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n + 1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。（2）创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p><p><strong>4.线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果要保证线程安全的话就使用 <code>ConcurrentHashMap</code> ）。</p><p><strong>5.效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它。</p><h3 id="了解-HashMap-的-put-方法吗"><a href="#了解-HashMap-的-put-方法吗" class="headerlink" title="了解 HashMap 的 put 方法吗?"></a>了解 HashMap 的 put 方法吗?</h3><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310092106561.png"></p><p>①.判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；</p><p>②.根据键值 key 计算 hash 值得到插入的数组索引i，如果 table[i]&#x3D;&#x3D;null，直接新建节点添加，转向 ⑥，如果table[i] 不为空，转向 ③；</p><p>③.判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向 ④，这里的相同指的是 hashCode 以及 equals；</p><p>④.判断table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向 ⑤；</p><p>⑤.遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。</p><p>JDK 1.8 HashMap 的 put 方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// 对key的hashCode()做hash</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// 步骤①：tab为空则创建</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 步骤②：计算index，并对null做处理 </span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>) <br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 步骤③：节点key存在，直接覆盖value</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 步骤④：判断该链为红黑树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 步骤⑤：该链为链表</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key,value,<span class="hljs-literal">null</span>);<br>                     <span class="hljs-comment">//链表长度大于8转换为红黑树进行处理</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st  </span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                 <span class="hljs-comment">// key已经存在直接覆盖value</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) <br>                           <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 步骤⑥：超过最大容量 就扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK-1-8-对-HashMap-做了哪些优化"><a href="#JDK-1-8-对-HashMap-做了哪些优化" class="headerlink" title="JDK 1.8 对 HashMap 做了哪些优化?"></a>JDK 1.8 对 HashMap 做了哪些优化?</h3><p><strong>1.数据结构：</strong>JDK 1.7 采用数组 + 链表，JDK 1.8 采用数组 + 链表或红黑树；</p><p><strong>2.链表插入方式：</strong>JDK 1.7 采用头插法，JDK 1.8 采用尾插法；</p><p><strong>3.扩容rehash：</strong> JDK 1.7 扩容时需要对原数组中的元素进行重新 hash 定位在新数组的位置，JDK 1.8 不需要重新通过 hash 函数计算位置，新的位置不变或索引 + 新增容量大小；</p><p><strong>4.扩容时机：</strong>JDK 1.7 先判断是否需要扩容再插入，JDK 1.8 先进行插入，插入完成再判断是否需要扩容；</p><p><strong>5.散列函数：</strong>JDK 1.7 做了四次移位和四次异或，JDK 1.8 只做一次。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="ConcurrentHashMap-底层具体实现知道吗"><a href="#ConcurrentHashMap-底层具体实现知道吗" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗?"></a>ConcurrentHashMap 底层具体实现知道吗?</h3><p>JDK 1.8 之前：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310122144862.jpg"></p><p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。<code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p><p>JDK 1.8 之后：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310122202709.jpg"></p><p>JDK 1.8 中<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。JDK 1.8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p><blockquote><p><strong>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同?</strong></p><p><strong>1. 线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK 1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p><p><strong>2. Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK 1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p><p><strong>3. 并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p></blockquote><h3 id="为什么要用ConcurrentHashMap"><a href="#为什么要用ConcurrentHashMap" class="headerlink" title="为什么要用ConcurrentHashMap?"></a>为什么要用ConcurrentHashMap?</h3><p><code>HashMap</code> 是<strong>线程不安全</strong>的。</p><blockquote><p><strong>为什么说 HashMap 线程不安全?</strong></p><p>1.多线程下扩容死循环。JDK 1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK 1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</p><p>2.多线程的 put 可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK 1.7 和 JDK 1.8 中都存在。</p><p>3.put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出 threshold 而导致 rehash，线程 2 此时执行 get，有可能导致这个问题。此问题在 JDK 1.7 和 JDK 1.8 中都存在。</p></blockquote><p><code>HashTable</code> 是<strong>线程安全</strong>的，但是 <code>HashTable</code> 的效率太低了。</p><blockquote><p><strong>为什么说 HashTable 效率低下?</strong></p><p><code>HashTable</code> 使用 <code>synchronized</code> 关键字来保证线程安全。当一个线程访问 <code>HashTable</code> 的同步方法，其他线程也访问 <code>HashTable</code> 的同步方法就会进入阻塞或轮询状态。可以理解 <code>HashTable</code> 只有一把锁，所有的线程不管做什么，都是竞争这一把锁。</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>本文仅用于个人学习，不涉及出售或倒卖</p><p>文中部分引用 JavaGuide 博主网站中的内容，<a href="https://javaguide.cn/">了解详情戳此处</a>。</p><p>文中部分引用 keyjane 作者 Github 空间中的内容。<a href="https://github.com/keyjane/2019_campus_apply/blob/master/notes/JavaArchitecture/02%20Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.md#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE">了解详情戳此处</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础篇</title>
    <link href="/posts/4c564f26.html"/>
    <url>/posts/4c564f26.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 01, 2023</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的几种基本数据类型了解吗"><a href="#Java-中的几种基本数据类型了解吗" class="headerlink" title="Java 中的几种基本数据类型了解吗?"></a>Java 中的几种基本数据类型了解吗?</h3><p>Java 中有 8 种基本数据类型，分别为：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>blooean</code>。</p><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310011802831.png"></p><p>可以看到，像 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>能表示的最大正数都减 1 了，这是因为在二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p><h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别?"></a>基本类型和包装类型的区别?</h3><p>Java 的每个基本类型都对应了一个包装类型，即：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><p><strong>区别：</strong></p><p>1.包装类型可以为 <code>null</code>，而基本类型不可以 。</p><p>2.包装类型可用于泛型，而基本类型不可以 。</p><p>3.基本类型比包装类型更高效（基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用）。</p><p>4.相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p>5.对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h3 id="自动装箱与拆箱了解吗"><a href="#自动装箱与拆箱了解吗" class="headerlink" title="自动装箱与拆箱了解吗?"></a>自动装箱与拆箱了解吗?</h3><p>有了基本类型和包装类型，肯定有些时候要在它们之间进行转换。</p><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p><p>在 JDK 1.5之前，需要开发人员手动进行装拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 手动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue(); <span class="hljs-comment">// 手动拆箱</span><br></code></pre></td></tr></table></figure><p>在 JDK 1.5之后，为了简化开发人员的工作 Java 提供了自动装拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">// 自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">// 自动拆箱</span><br><br>=&gt;<br>    <br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></td></tr></table></figure><p>也就是说，自动装箱是调用包装类的<code>valueOf()</code>方法完成的；自动拆箱是调用 <code>xxxValue()</code> 方法完成的。</p><p><strong>注意：</strong>应该尽量避免不必要的装拆箱操作，因为频繁装拆箱会严重影响系统的性能。</p><h3 id="包装类型的缓存机制了解吗"><a href="#包装类型的缓存机制了解吗" class="headerlink" title="包装类型的缓存机制了解吗?"></a>包装类型的缓存机制了解吗?</h3><p>Java 基本数据类型的包装类型（除了Float和Double）都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回<code>true</code>或<code>false</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 下面的代码的输出结果是 true 还是 false?</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>System.out.println(i==j);<br></code></pre></td></tr></table></figure><p><code>Integer i = 10</code>这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i = Integer.valueOf(10)</code> 。因此，<code>i</code> 直接使用的是缓存中的对象。而<code>Integer j = new Integer(10)</code> 会直接创建新的对象。所以答案是<code>false</code>。</p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="Final关键字有什么作用"><a href="#Final关键字有什么作用" class="headerlink" title="Final关键字有什么作用?"></a>Final关键字有什么作用?</h3><p>1.被final修饰的类不可以被继承 。</p><p>2.被final修饰的方法不可以被重写 。</p><p>3.被final修饰的变量不可以被改变。</p><p>4.被final修饰不可变的是变量的引用，而不是引用指向的内容， 引用指向的内容是可以改变的。</p><h3 id="什么是重载（Overload）和重写（Override）"><a href="#什么是重载（Overload）和重写（Override）" class="headerlink" title="什么是重载（Overload）和重写（Override）?"></a>什么是重载（Overload）和重写（Override）?</h3><p><strong>重载：</strong>发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分 。</p><p><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，子类方法返回值小于等于父类，抛出的异常范围小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明；构造方法无法被重写。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/java-interview-images/202310012252672.png"></p><h3 id="知道-和-equals-的区别吗"><a href="#知道-和-equals-的区别吗" class="headerlink" title="知道&#x3D;&#x3D; 和 equals() 的区别吗?"></a>知道&#x3D;&#x3D; 和 equals() 的区别吗?</h3><p><code>==</code>  的作用是判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象。(对于基本数据类型 <code>==</code> 比较的是值，对于引用数据类型 <code>==</code> 比较的是对象的内存地址)。</p><blockquote><p>因为 Java 只有值传递，所以对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Object类中的equals()方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>     <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><p>1.类没有重写 <code>equals()</code>方法：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是<code>Object</code>类中的<code>equals()</code>方法。</p><p>2.类重写了 <code>equals()</code>方法：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</p><h3 id="hashCode三连问"><a href="#hashCode三连问" class="headerlink" title="hashCode三连问"></a>hashCode三连问</h3><h4 id="hashCode-有什么用"><a href="#hashCode-有什么用" class="headerlink" title="hashCode()有什么用?"></a>hashCode()有什么用?</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。散列表存储的是键值对(key-value)，它的特点是：<strong>能根据”键”快速的检索出对应的”值”，这其中就利用到了散列码（可以快速找到所需要的对象）。</strong></p><h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode?"></a>为什么要有 hashCode?</h4><p>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</p><p>如果两个对象的<code>hashCode</code> 值相等，那这两个对象也不一定相等（哈希碰撞）。</p><blockquote><p><strong>哈希碰撞：</strong><code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p></blockquote><p>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p><h4 id="为什么重写-equals-时必须重写-hashCode-方法"><a href="#为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法?"></a>为什么重写 equals() 时必须重写 hashCode() 方法?</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><h3 id="String、StringBuffer、StringBuilder-的区别"><a href="#String、StringBuffer、StringBuilder-的区别" class="headerlink" title="String、StringBuffer、StringBuilder 的区别?"></a>String、StringBuffer、StringBuilder 的区别?</h3><p><strong>可变性：</strong><code>String</code>类中使用字符数组保存字符串，所以<code>string</code>对象是不可变的。<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><blockquote><p><strong>String 为什么是不可变的?</strong></p><p>1.保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</p><p>2.<code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p></blockquote><p><strong>线程安全性：</strong><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能：</strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><blockquote><p><strong>总结：</strong></p><p>1.操作少量的数据: 适用 <code>String</code></p><p>2.单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></p><p>3.多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></p></blockquote><h3 id="知道泛型吗-有什么作用"><a href="#知道泛型吗-有什么作用" class="headerlink" title="知道泛型吗?有什么作用?"></a>知道泛型吗?有什么作用?</h3><p><strong>泛型（Generics）</strong> 是 JDK 5 引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p><h3 id="知道注解吗-注解的解析方法有哪几种"><a href="#知道注解吗-注解的解析方法有哪几种" class="headerlink" title="知道注解吗?注解的解析方法有哪几种?"></a>知道注解吗?注解的解析方法有哪几种?</h3><p><strong>注解（Annotation）</strong>是 JDK 5 引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。JDK 提供了很多内置的注解（比如 <code>@Override</code>、<code>@Deprecated</code>），同时我们还可以自定义注解。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Override</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注解只有被解析之后才会生效，常见的<strong>解析方法</strong>有两种：</p><p><strong>1.编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</p><p><strong>2.运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</p><h3 id="知道反射吗-有什么优缺点"><a href="#知道反射吗-有什么优缺点" class="headerlink" title="知道反射吗?有什么优缺点?"></a>知道反射吗?有什么优缺点?</h3><p><strong>反射（Reflection）</strong>是指在运行状态中，对于任意一个类都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为 Java 语言的反射。</p><p><strong>优点：</strong>可以在运行期进行类型的判断，动态加载类，提高代码灵活度，为各种框架提供开箱即用的功能提供了便利。</p><p><strong>缺点：</strong>增加了安全问题（比如可以无视泛型参数的安全检查），性能瓶颈。</p><blockquote><p>反射的应用场景</p><p>1.在我们的项目中经常会使用反射 + 自定义注解的方式去实现一些功能，比如：在前后端交互的时候, 后端 Long 类型返回前端后会产生精度丢失 , 我们的处理方式就是在服务端, 通过配置修改 Jackson 的序列化规则, 将一些 Long 类型字段转化为字符串返回给前端, 这个时候我们自定义了一个@IdEncrpt注解 , 通过反射获取类的属性, 判断属性上是否添加了@IdEncrpt注解, 如果添加了 , 就会通过反射获取属性值, 转化为字符串。</p><p>2.像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制（这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射）。</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>本文仅用于个人学习，不涉及出售或倒卖</p><p>文中部分引用 JavaGuide 博主网站中的内容，<a href="https://javaguide.cn/">了解详情戳此处</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
