<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础篇</title>
    <link href="/posts/4c564f26.html"/>
    <url>/posts/4c564f26.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 01, 2023</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的几种基本数据类型了解吗？"><a href="#Java-中的几种基本数据类型了解吗？" class="headerlink" title="Java 中的几种基本数据类型了解吗？"></a>Java 中的几种基本数据类型了解吗？</h3><p>Java 中有 8 种基本数据类型，分别为：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>blooean</code>。</p><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/Java-Basics/202310011802831.png"></p><p>可以看到，像 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>能表示的最大正数都减 1 了，这是因为在二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p><h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><p>Java 的每个基本类型都对应了一个包装类型，即：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><p><strong>区别：</strong></p><p>1.包装类型可以为 <code>null</code>，而基本类型不可以 。</p><p>2.包装类型可用于泛型，而基本类型不可以 。</p><p>3.基本类型比包装类型更高效（基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用）。</p><p>4.相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p>5.对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h3 id="自动装箱与拆箱了解吗？"><a href="#自动装箱与拆箱了解吗？" class="headerlink" title="自动装箱与拆箱了解吗？"></a>自动装箱与拆箱了解吗？</h3><p>有了基本类型和包装类型，肯定有些时候要在它们之间进行转换。</p><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p><p>在 Java 1.5之前，需要开发人员手动进行装拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//手动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue(); <span class="hljs-comment">//手动拆箱</span><br></code></pre></td></tr></table></figure><p>在 Java 1.5之后，为了简化开发人员的工作 Java 提供了自动装拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//自动拆箱</span><br><br>=&gt;<br>    <br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></td></tr></table></figure><p>也就是说，自动装箱是调用包装类的<code>valueOf()</code>方法完成的；自动拆箱是调用 <code>xxxValue()</code> 方法完成的。</p><p><strong>注意：</strong>应该尽量避免不必要的装拆箱操作，因为频繁装拆箱会严重影响系统的性能。</p><h3 id="包装类型的缓存机制了解吗？"><a href="#包装类型的缓存机制了解吗？" class="headerlink" title="包装类型的缓存机制了解吗？"></a>包装类型的缓存机制了解吗？</h3><p>Java 基本数据类型的包装类型（除了Float和Double）都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回<code>true</code>或<code>false</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//下面的代码的输出结果是 true 还是 false？</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>System.out.println(i==j);<br></code></pre></td></tr></table></figure><p><code>Integer i = 10</code>这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i = Integer.valueOf(10)</code> 。因此，<code>i</code> 直接使用的是缓存中的对象。而<code>Integer j = new Integer(10)</code> 会直接创建新的对象。所以答案是<code>false</code>。</p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="Final关键字有什么作用？"><a href="#Final关键字有什么作用？" class="headerlink" title="Final关键字有什么作用？"></a>Final关键字有什么作用？</h3><p>1.被final修饰的类不可以被继承 。</p><p>2.被final修饰的方法不可以被重写 。</p><p>3.被final修饰的变量不可以被改变。</p><p>4.被final修饰不可变的是变量的引用，而不是引用指向的内容， 引用指向的内容是可以改变的。</p><h3 id="什么是重载（Overload）和重写（Override）"><a href="#什么是重载（Overload）和重写（Override）" class="headerlink" title="什么是重载（Overload）和重写（Override）?"></a>什么是重载（Overload）和重写（Override）?</h3><p><strong>重载：</strong>发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分 。</p><p><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，子类方法返回值小于等于父类，抛出的异常范围小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明；构造方法无法被重写。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/Java-Basics/202310012252672.png"></p><h3 id="知道-和-equals-的区别吗？"><a href="#知道-和-equals-的区别吗？" class="headerlink" title="知道&#x3D;&#x3D; 和 equals() 的区别吗？"></a>知道&#x3D;&#x3D; 和 equals() 的区别吗？</h3><p><code>==</code>  的作用是判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象。(对于基本数据类型 <code>==</code> 比较的是值，对于引用数据类型 <code>==</code> 比较的是对象的内存地址)。</p><blockquote><p>因为 Java 只有值传递，所以对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Object类中的equals()方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>     <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><p>1.类没有重写 <code>equals()</code>方法：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是<code>Object</code>类中的<code>equals()</code>方法。</p><p>2.类重写了 <code>equals()</code>方法：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/posts/7065.html"/>
    <url>/posts/7065.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on Augst 18, 2023</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习Git之前，我们需要先理解以下几个概念：</p><blockquote><p>什么是Git？</p></blockquote><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><blockquote><p>什么是版本控制系统？</p></blockquote><p>版本控制系统是一种帮助软件开发者实现团队合作和历史版本维护的软件，一个版本控制系统应具备以下列出的这几个基本功能：</p><ul><li>允许开发者并发工作</li><li>不允许一个开发者覆写另一个开发者的修改</li><li>保存所有版本历史</li></ul><blockquote><p>版本控制系统分为几类？</p></blockquote><p>版本控制系统可以分为：集中式版本控制系统、去中心式（<strong>分布式</strong>）版本控制系统。</p><blockquote><p>什么是集中式版本控制系统？</p></blockquote><p>集中式的版本控制系统，所有的版本库是放在中央服务器中的，简单说就是我们每一次的修改提交都是保存在中央服务器中的。中央服务器就是个大仓库，大家把产品都堆里面，每一次需要修改的时候，需要去仓库里面把文件给提出来，然后再操作。这就可能导致协同工作时提交文件不完整，版本库损坏等问题。</p><blockquote><p>什么是分布式版本控制系统？</p></blockquote><p>分布式版本控制系统，每台计算机上都有一个完整的版本库。你的修改仅仅需要提交给本地的版本库进行保存就可以了。那它怎么能做到协同呢？不同于集中式版本控制系统的”中央服务器”，分布式版本控制系统可以通过推送版本库，实现不同的计算机之间的版本共享。举个例子，对于同一个文件，如果两个人同时对它进行了修改，最新的版本应该都保存在各自的计算机中，想要实现协同开发，只需要将各自的最新版本库推送给对方，就可以得到最新的版本库了。</p><h2 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h2><blockquote><p>Git中的常用概念</p></blockquote><ul><li><p>版本库：.git隐藏文件夹就是版本库其中存储了很多配置信息，日志信息，文件版本信息等。</p></li><li><p>工作区：包含.git文件夹的目录就是工作区（工作目录），主要用于存放开放的代码。</p></li><li><p>暂存区：.git文件夹中的index文件就是暂存区(也可以叫做stage)，一个临时保存修改文件的地方。</p></li></ul><h3 id="1-获取Git仓库"><a href="#1-获取Git仓库" class="headerlink" title="1.获取Git仓库"></a>1.获取Git仓库</h3><h4 id="（1）在本地初始化Git仓库"><a href="#（1）在本地初始化Git仓库" class="headerlink" title="（1）在本地初始化Git仓库"></a>（1）在本地初始化Git仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">在任意目录下创建一个空目录作为本地Git仓库<br><br>进入这个目录，点击右键打开Git bash窗口<br><br>执行命令 git init<br></code></pre></td></tr></table></figure><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181655103.png"></p><p>执行git init命令后再去刚才的目录下查看是否生成了.git文件夹（隐藏文件夹）</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181657367.png"></p><h4 id="（2）从远程仓库克隆"><a href="#（2）从远程仓库克隆" class="headerlink" title="（2）从远程仓库克隆"></a>（2）从远程仓库克隆</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">首先在Github或者Gitee上创建一个仓库<br><br>在一个目录下执行命令 git <span class="hljs-built_in">clone</span> [远程Git仓库地址]<br></code></pre></td></tr></table></figure><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181729102.png"></p><h3 id="2-本地仓库常用命令"><a href="#2-本地仓库常用命令" class="headerlink" title="2.本地仓库常用命令"></a>2.本地仓库常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status     ---查看文件状态<br></code></pre></td></tr></table></figure><p>首先进入刚刚克隆下来的目录，再执行git status。可以看到现在在main分支，由于是新仓库所以还没有提交信息。</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181731864.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add [* 或者 文件名]     ---将文件的修改加入暂存区<br></code></pre></td></tr></table></figure><p>在仓库中手动创建一个a.txt文件，然后执行git add命令，再查看状态。</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181735833.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;提示信息&quot;</span> [文件名]     ---将暂存区的文件修改提交到版本库<br></code></pre></td></tr></table></figure><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181737332.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>     ---查看日志<br></code></pre></td></tr></table></figure><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181738272.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard [版本号]     ---将暂存区的文件取消暂存或者切换到指定版本<br></code></pre></td></tr></table></figure><h3 id="3-远程仓库常用命令"><a href="#3-远程仓库常用命令" class="headerlink" title="3.远程仓库常用命令"></a>3.远程仓库常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote -v     ---查看远程仓库<br></code></pre></td></tr></table></figure><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181749521.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add [short-name] &lt;url&gt;     ---添加远程仓库<br></code></pre></td></tr></table></figure><p>首先在本地创建一个文件夹执行git init命令，然后在Github或者Gitee上创建一个同名的仓库，再执行上面添加远程仓库的命令。</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181757432.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;url&gt;     ---从远程仓库克隆<br></code></pre></td></tr></table></figure><p>克隆命令之前已经展示过，不再演示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull [short-name] [branch-name]     ---从远程仓库拉取<br></code></pre></td></tr></table></figure><p class="note note-warning">如果当前本地仓库不是从远程克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件会报错(fatal: refusing to merge unrelated histories)，解决此问题可以在git pull 命令后加入参数--allow-unrelated-histories。</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181807404.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push [remote-name] [branch-name]     ---推送到远程仓库<br></code></pre></td></tr></table></figure><p>回到之前从远程克隆的Test仓库，我们之前在Test目录下创建了一个a.txt文件，现在将其推送到远程仓库。</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181803475.png"></p><p>再去远程仓库查看是否推送成功</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181804033.png"></p><h3 id="4-分支操作"><a href="#4-分支操作" class="headerlink" title="4.分支操作"></a>4.分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch     ---列出所有本地分支<br><br>git branch -r      ---列出所有远程分支<br><br>git branch -a     ---列出所有本地和远程分支<br></code></pre></td></tr></table></figure><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181853694.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch [name]     ---创建分支<br></code></pre></td></tr></table></figure><p>创建b1分支</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181856090.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout [name]     ---切换分支<br></code></pre></td></tr></table></figure><p>切换到b1分支</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181856193.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push [short-name] [name]     ---推送至远程仓库分支<br></code></pre></td></tr></table></figure><p>推送到b1分支</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181859250.png"></p><p>在远程仓库的b1分支下也出现了a.txt文件</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181901899.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge [name]     ---合并分支<br></code></pre></td></tr></table></figure><p>先在本地仓库创建一个test.txt文件，然后推送到远程仓库的b1分支</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181912934.png"></p><p>执行上面的合并分支命令即可将b1分支的内容合并到main分支</p><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181914555.png"></p><h3 id="5-标签操作"><a href="#5-标签操作" class="headerlink" title="5.标签操作"></a>5.标签操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag [name]     ---创建标签<br><br>git tag     ---列出已有标签<br></code></pre></td></tr></table></figure><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181918171.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push [short-name] [name]     ---将标签推送至远程仓库<br></code></pre></td></tr></table></figure><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181921225.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b [branch] [name]     ---检出标签<br></code></pre></td></tr></table></figure><p><img src="https://holary-blog-images-1320152118.cos.ap-chengdu.myqcloud.com/blog-images/202308181923497.png"></p>]]></content>
    
    
    <categories>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
