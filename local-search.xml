<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础篇</title>
    <link href="/posts/4c564f26.html"/>
    <url>/posts/4c564f26.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Last updated on October 01, 2023</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的几种基本数据类型了解吗？"><a href="#Java-中的几种基本数据类型了解吗？" class="headerlink" title="Java 中的几种基本数据类型了解吗？"></a>Java 中的几种基本数据类型了解吗？</h3><p>Java 中有 8 种基本数据类型，分别为：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>blooean</code>。</p><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/Java-Basics/202310011802831.png"></p><p>可以看到，像 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>能表示的最大正数都减 1 了，这是因为在二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p><h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><p>Java 的每个基本类型都对应了一个包装类型，即：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><p><strong>区别：</strong></p><p>1.包装类型可以为 <code>null</code>，而基本类型不可以 。</p><p>2.包装类型可用于泛型，而基本类型不可以 。</p><p>3.基本类型比包装类型更高效（基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用）。</p><p>4.相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p>5.对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h3 id="自动装箱与拆箱了解吗？"><a href="#自动装箱与拆箱了解吗？" class="headerlink" title="自动装箱与拆箱了解吗？"></a>自动装箱与拆箱了解吗？</h3><p>有了基本类型和包装类型，肯定有些时候要在它们之间进行转换。</p><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p><p>在 Java 1.5之前，需要开发人员手动进行装拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//手动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue(); <span class="hljs-comment">//手动拆箱</span><br></code></pre></td></tr></table></figure><p>在 Java 1.5之后，为了简化开发人员的工作 Java 提供了自动装拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//自动拆箱</span><br><br>=&gt;<br>    <br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></td></tr></table></figure><p>也就是说，自动装箱是调用包装类的<code>valueOf()</code>方法完成的；自动拆箱是调用 <code>xxxValue()</code> 方法完成的。</p><p><strong>注意：</strong>应该尽量避免不必要的装拆箱操作，因为频繁装拆箱会严重影响系统的性能。</p><h3 id="包装类型的缓存机制了解吗？"><a href="#包装类型的缓存机制了解吗？" class="headerlink" title="包装类型的缓存机制了解吗？"></a>包装类型的缓存机制了解吗？</h3><p>Java 基本数据类型的包装类型（除了Float和Double）都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回<code>true</code>或<code>false</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//下面的代码的输出结果是 true 还是 false？</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>System.out.println(i==j);<br></code></pre></td></tr></table></figure><p><code>Integer i = 10</code>这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i = Integer.valueOf(10)</code> 。因此，<code>i</code> 直接使用的是缓存中的对象。而<code>Integer j = new Integer(10)</code> 会直接创建新的对象。所以答案是<code>false</code>。</p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="Final关键字有什么作用？"><a href="#Final关键字有什么作用？" class="headerlink" title="Final关键字有什么作用？"></a>Final关键字有什么作用？</h3><p>1.被final修饰的类不可以被继承 。</p><p>2.被final修饰的方法不可以被重写 。</p><p>3.被final修饰的变量不可以被改变。</p><p>4.被final修饰不可变的是变量的引用，而不是引用指向的内容， 引用指向的内容是可以改变的。</p><h3 id="什么是重载（Overload）和重写（Override）"><a href="#什么是重载（Overload）和重写（Override）" class="headerlink" title="什么是重载（Overload）和重写（Override）?"></a>什么是重载（Overload）和重写（Override）?</h3><p><strong>重载：</strong>发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分 。</p><p><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，子类方法返回值小于等于父类，抛出的异常范围小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明；构造方法无法被重写。</p><p><img src="https://blog-1320152118.cos.ap-chengdu.myqcloud.com/Java-Basics/202310012252672.png"></p><h3 id="知道-和-equals-的区别吗？"><a href="#知道-和-equals-的区别吗？" class="headerlink" title="知道&#x3D;&#x3D; 和 equals() 的区别吗？"></a>知道&#x3D;&#x3D; 和 equals() 的区别吗？</h3><p><code>==</code>  的作用是判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象。(对于基本数据类型 <code>==</code> 比较的是值，对于引用数据类型 <code>==</code> 比较的是对象的内存地址)。</p><blockquote><p>因为 Java 只有值传递，所以对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Object类中的equals()方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>     <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><p>1.类没有重写 <code>equals()</code>方法：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是<code>Object</code>类中的<code>equals()</code>方法。</p><p>2.类重写了 <code>equals()</code>方法：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
